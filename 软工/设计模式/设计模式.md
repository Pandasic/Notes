---
title: 设计模式
tag: [计算机课程学习,软工,设计模式,]
---
# 设计模式

[toc]

## 简介

* [**原则**](#原则) 指导了设计模式构建思想

*   单一职责原则

*   开放封闭原则
*   依赖倒置原则

*   接口隔离原则
*   迪米特法则
*   里氏替换原则

### 创建型模式

 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

*   工厂模式（Factory Pattern）
*   抽象工厂模式（Abstract Factory Pattern）
*   单例模式（Singleton Pattern）
*   建造者模式（Builder Pattern）
*   原型模式（Prototype Pattern）
### 结构型模式

 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

*   适配器模式（Adapter Pattern）
*   桥接模式（Bridge Pattern）
*   过滤器模式（Filter. Criteria Pattern）
*   组合模式（Composite Pattern）
*   装饰器模式（Decorator Pattern）
*   外观模式（Facade Pattern）
*   享元模式（Flyweight Pattern）
*   代理模式（Proxy Pattern）
### 行为型模式

 这些设计模式特别关注对象之间的通信。

*   责任链模式（Chain of Responsibility Pattern）
*   命令模式（Command Pattern）
*   解释器模式（Interpreter Pattern）
*   迭代器模式（Iterator Pattern）
*   中介者模式（Mediator Pattern）
*   备忘录模式（Memento Pattern）
*   观察者模式（Observer Pattern）
*   状态模式（State Pattern）
*   空对象模式（Null Object Pattern）
*   策略模式（Strategy Pattern）
*   模板模式（Template Pattern）
*   访问者模式（Visitor Pattern）

## 原则

> 参考自：
>
> ​	http://www.uml.org.cn/sjms/201211023.asp
>
> ​	https://www.jianshu.com/p/8cbc4bf897cb

设计模式体现了代码的耦合性， 内聚性以及可维护性，可扩展性，重用性，灵活性。

### 单一职责原则

不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。

1. 降低类的复杂度，一个类只负责一项职责；

2. 提高类的可读性，可维护性；

3. 降低变更引起的风险;

4. 通常情况下，应当遵守单一职责原则， 只有逻辑足够简单，才可以在方法级违反单一职责原则。

### 开放封闭原则

2. 一个软件实体，比如类，模块和函数应该对提供方扩展开放，对使用方修改关闭。用抽象构建框架，用实现扩展细节；

3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；

4. 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

### 依赖倒置原则

高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象（缓冲层）；

2. 抽象不应该依赖细节，细节应该依赖抽象；

3. 依赖倒转(倒置)的中心思想是面向接口编程;

4. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中， 抽象指的是接口或抽象类，细节就是具体的实现类；

5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。

### 接口隔离原则

客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

1. 类A通过接口 Interface1. 2 依赖类B，类C通过接口 Interface1. 3 依赖类D，如果接口 Interface 对于 类A 和 类C 来说不是最小接口，那么 类B 和 类D 必须去实现他们不需要的方法。

2. 将接口 Interface 拆分为独立的几个接口，类A 和 类C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

3. 接口 Interface 中出现的方法，根据实际情祝拆分为三个接口。

依赖关系三种传递方式：

- 接口传递（依赖）
- 构造方法传递（依赖）
- setter方式传递（聚合）

### 迪米特法则

1. 一个对象应该对其他对象保持最少的了解（最少知道原则 LKP）。

2. 类与类关系越密切，耦合度越大。要求降低类之间耦合，而不是完全解耦。

3. 迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。

4. 迪米特法则更简单的定义：只与直接的朋友通信。

5. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

### 里氏替换原则

2. 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象；
3. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法；
4. 继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题；
5. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。

## 创建型模式

这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

### 工厂模式（Factory Pattern）

## 抽象工厂模式（Abstract Factory Pattern）

### 单例模式（Singleton Pattern）

### 建造者模式（Builder Pattern）

### 原型模式（Prototype Pattern）

## 结构型模式

这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 
###  适配器模式（Adapter Pattern）
###  桥接模式（Bridge Pattern）
###  过滤器模式（Filter. Criteria Pattern）
###  组合模式（Composite Pattern）
###  装饰器模式（Decorator Pattern）
###  外观模式（Facade Pattern）
###  享元模式（Flyweight Pattern）
###  代理模式（Proxy Pattern）
## 行为型模式 这些设计模式特别关注对象之间的通信。
###  责任链模式（Chain of Responsibility Pattern）
###  命令模式（Command Pattern）
###  解释器模式（Interpreter Pattern）
###  迭代器模式（Iterator Pattern）
###  中介者模式（Mediator Pattern）
###  备忘录模式（Memento Pattern）
###  观察者模式（Observer Pattern）
###  状态模式（State Pattern）
###  空对象模式（Null Object Pattern）

###  策略模式（Strategy Pattern）
###  模板模式（Template Pattern）
###  访问者模式（Visitor Pattern）