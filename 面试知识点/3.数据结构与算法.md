---
title: 3.数据结构与算法
tag: [计算机课程学习,面试知识点,]
---
# 数据结构与算法

## STL 

### map 和 unordered_map

#### 底层实现

map：红黑树 内部元素排列有序

unordered_map：基于哈希表 排列是无序的

#### 优缺点

###### map

\+ 有序性： 元素的有序性可以简化操作
\+ 查找、删除、增加操作时间复杂度稳定 为logn
\- 查找、删除、增加操作时间复杂度较慢  与n有关

##### unordered_map
\+ 查找、删除、增加操作时间复杂度快 为数O(c)
\- 基于哈希表 空间占用率高
\- 查找、删除、增加操作时间复杂度不稳定 极端情况下为O(n)

## epllo

### epllo 实现

Linux epoll 机制是通过红黑树和双向链表实现的。 

1. 首先通过 epoll_create()系统调用在内核中创建一个 eventpoll 类型的句柄，其中包括红黑树根节点和双向链表头节点。
2. 通过 epoll_ctl()系统调用，向 epoll 对象的红黑树结构中添加、删除、修改感兴趣的事件，返回 0标识成功，返回-1 表示失败。
3. 通过 epoll_wait()系统调用判断双向链表是否为空，如果为 空则阻塞。当文件描述符状态改变，fd 上的回调函数被调用，该函数将 fd 加入到双向链表中， 此时 epoll_wait 函数被唤醒，返回就绪好的事件。

## 编码

###  哈夫曼编码

哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件中出现的频率来建立使用 0，1 表示个字符的最优表示方式，

1. 哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树 T。 
2. 算法以|C|个叶结点开始，执行|C|－1 次的“合并”运算后产生最终所要求的树 T。
3. 假设编码字符集中每一字符 c 的频率是 f(c)。以 f 为键值的优先队列 Q 用在贪心选择时有效地确定算法当前要合并的 2 棵具有最小频率的树。一旦 2 棵具有最小频率的树合并后，产生 一棵新的树，其频率为合并的 2 棵树的频率之和，并将新树插入优先队列 Q。经过 n－1 次的合 并后，优先队列中只剩下一棵树，即所要求的树 T。

## 树

### [平衡二叉树（AVL树）](https://www.cnblogs.com/skywang12345/p/3576969.html)

平衡二叉树又称为 AVL 树，是一种特殊的**二叉排序树**。

其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过 1。一句话表述为：**以树中所有结点为根的树的左右子树高度之差 的绝对值不超过 1**。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF，那么平 衡二叉树上的所有结点的平衡因子只可能是-1、0 和 1。只要二叉树上有一个结点的平衡因子的 绝对值大于 1，则该二叉树就是不平衡的。

### [红黑树](https://www.cnblogs.com/skywang12345/p/3245399.html)

红黑树是一种**二叉查找树**，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确**保没有一 条路径会比其它路径长出两倍**，因此，红黑树是一种弱平衡二叉树，相对于要求严格的 AVL 树来 说，它的**旋转次数少**，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

性质： 

* 每个节点非红即黑 
* 根节点是黑的; 
* 每个叶节点（叶节点即树尾端 NULL 指针或 NULL 节点）都是黑的; 
* 如果一个节点是红色的，则它的子节点必须是黑色的。
* 对于任意节点而言，其到叶子点树 NULL 指针的每条路径都包含相同数目的**黑节点**;

### 红黑树和AVL树比较

红黑树较 AVL 树的优点： 

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的 rebalance，导致效率下降；

红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

 所以红黑树在查找，插入删除的性能都是 O(logn)，且性能稳定，所以 STL 里面很多结构包
括 map 底层实现都是使用的红黑树。

### [B树/B+树](https://zhuanlan.zhihu.com/p/27700617)

B+是一种**多路搜索树**，主要为磁盘或其他直接存取辅助设备而设计的一种**平衡查找树**，在
B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键 值的大小顺序存放在同一层的叶节点中。相比 B 树，其具有以下几个特点：
每个节点上的指针上限为 2d 而不是 2d+1（d 为节点的出度）
内节点不存储 data,只存储 key 叶子节点不存储指针

## 堆与栈

### 栈溢出

栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。 

栈溢出的原因： 

* 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈
  中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配， 使用堆（heap）而不是栈（stack）。
* 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致
  堆栈溢出。 
* 指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。'

## 堆

堆是一棵完全二叉树（如果一共有 h 层，那么 1~h-1 层均满，在 h 层可能会连续缺失若干
个右叶子）。 

#### 小根堆

若根节点存在左子女则根节点的值小于左子女的值；

若根节点存在右子女则根节点的值小于右子女的值。

#### 大根堆

若根节点存在左子女则根节点的值大于左子女的值；

若根节点存在右子女则根节点的值大于右子女的值。

#### 时间复杂度

建堆 O(n)

重建堆 O(nlogn)

### 堆栈区别

| 堆                                | 栈                 |
| --------------------------------- | ------------------ |
| 低地址向高地址扩展                | 高地址向低地址扩展 |
| 内存需要手动申请和释放            | OS 自动申请和释放  |
| 频繁调用malloc和free 产生内存碎片 | 不会产生内存碎片   |
| 分配效率低                        | 分配效率高         |

> 栈效率高的原因
>
> 栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；
>
> 而堆是由 C/C++函数库提供的，机制复杂，需要一些 列分配内存、合并内存和释放内存的算法，因此效率较低'

## 哈希表

### 解决哈希冲突的方法

1. 开放地址方法
      1. 线性探测
      2. 按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。　

        　　（2）再平方探测

            　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。
            
            　　（3）伪随机探测
            
            　　　按顺序决定值时，如果某数据已经存在，通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。

2. 链式地址法（HashMap的哈希冲突解决方法）

    * 对于相同的值，使用链表进行连接。使用数组存储每一个链表。
    * 优点：

    　　	1. 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
                　　	2. 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况
             　　	3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
                         　　	4. 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可

    * 缺点：

    　　指针占用较大空间时，会造成空间浪费，若空间用于增大散列表规模进而提高开放地址法的效率。

3. 建立公共溢出区

　　建立公共溢出区存储所有哈希冲突的数据。

4. 再哈希法

　　对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。

## 数组与链表

### 数组

* 数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。、
* 数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都 要向后移。
* 删除数据时，这个数据后面的数据都要往前移动。
* 但数组的随机读取效率很高。因为 数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
* 如果应用需要快速访 问数据，很少或不插入和删除元素，就应该用数组。
* 数组需要预留空间，在使用前要先申请占内 存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。
* 数组的优点： 
  *  随机访问性强 
  *  查找速度快 
* 数组的缺点: 
  * 插入和删除效率低 
  * 可能浪费内存内存空间要求高，必须有足够的连续内存空间。
  *  数组大小固定，不能动态拓展

### 链表

* 链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。
* 如果要访问链表中一个元素， 需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构 就非常简单了，只要修改元素中的指针就可以了。
* 如果应用需要经常插入和删除元素你就需要用 链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。
* 链表的优点: 
  *  插入删除速度快 
  *  内存利用率高，不会浪费内存 
  * 大小没有固定，拓展很灵活。 
* 链表的缺点: 
  * 不能随机查找，必须从第一个开始遍历，查找效率低

## 排序

### [快排](F:\Projects\AlgorithmExercises\DataStructure\quicksort.cpp)

* 插入排序

对于一个带排序数组来说，其初始有序数组元素个数为 1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插 入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前 元素的下一位中。

* 希尔排序

先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段 分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关， 其最后一个值必须为 1.

* 归并排序

该算法采用分治法；对于包含 m 个元素的待排序序列，将其看成 m 个长度为 1
的子序列。然后两两合归并，得到 n/2 个长度为 2 或者 1 的有序子序列；然后再两两归并，直到 得到 1 个长度为 m 的有序序列。

* 冒泡排序

对于包含 n 个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前 前 n-i 个元素中的最大的元素移到 n-i 位置。遍历 n 次，完成排序。

* 快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过 程可以递归进行，以此达到整个数据变成有序序列。

* 选择排序

每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加 1，无序数组元素减 1.初始时无序数组为空。 

* 堆排序

堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素 交换位置，此时末尾元素就是最大/最小的值。然后将剩余 n-1 个元素重新构造成最大堆/最小堆。

| 排序方法     | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度  | 稳定性 | 复杂性 |
| ------------ | ---------------- | ---------------- | ---------------- | ----------- | ------ | ------ |
| 直接插入排序 | O(n^2)           | O(n^2)           | O(n)             | O(1)        | 稳定   | 简单   |
| 希尔排序     | O(nlog_2 n)      | O(n^2)           | O(n)             | O(1)        | 不稳   | 复杂   |
| 直接选择排序 | O(n^2)           | O(n^2)           | O(n^2)           | O(1)        | 不稳   | 简单   |
| 堆排序       | O(nlog_2 n)      | O(nlog_2 n)      | O(nlog_2 n)      | O(1)        | 不稳   | 复杂   |
| 冒泡排序     | O(n^2)           | O(n^2)           | O(n)             | O(1)        | 稳定   | 简单   |
| 快速排序     | O(nlog_2 n)      | O(n^2)           | O(nlog_2 n)      | O(nlog_2 n) | 不稳   | 复杂   |
| 归并排序     | O(nlog_2 n)      | O(nlog_2 n)      | O(nlog_2 n)      | O(1)        | 稳定   | 复杂   |

## 查找

### TOP(k)问题

* 直接全部排序（只适用于内存够的情况） 

  当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数
  据全部排序，然后取排序后的数据中的前 K 个。 这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出 top K 个数据，所以该方法并不十分高效，不建议使用。

* 快速排序的变形 （只使用于内存够的情况） 

  这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只
  需要找出前 K 个最大的就行。 这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号 index 刚好 等于 K，那么这个划分元以及它左边的数，刚好就是前 K 个最大的元素；如果 index > K，那么 前 K 大的数据在 index 的左边，那么就继续递归的从 index-1 个数中进行一趟排序；如果 index < K，那么再从划分元的右边继续进行排序，直到找到序号 index 刚好等于 K 为止。再将前 K 个 数进行排序后，返回 Top K 个元素。这种方法就避免了对除了 Top K 个元素以外的数据进行排序 所带来的不必要的开销。

* 最小堆法 这是一种局部淘汰法。

  先读取前 K 个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并 将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的 K 个数。

* 分治法 

  将全部数据分成 N 份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大
  的 K 个数。此时剩下 N*K 个数据，如果内存不能容纳 N*K 个数据，则再继续分治处理，分成 M 份，找出每份数据中最大的 K 个数，如果 M*K 个数仍然不能读到内存中，则继续分治处理。直到 剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

* Hash 法 如果这些数据中有很多重复的数据，可以先通过 hash 法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则 可以直接排序；否则可以使用分治法或者最小堆法来处理数据。

## 哈希

### hash 实现

构造哈希

对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数 法等。 

处理哈希

对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。SGL 版本使用链地址法，使用一个链表保持相同散列值的元素。 虽然链地址法并不要求哈希桶长度必须为质数，但 SGI STL 仍然以质数来设计哈希桶长度，并且将 28 个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用 来查询在这 28 个质数之中，“最接近某数并大于某数”的质数。
### rehash
 C++的 hash 表中有一个负载因子 loadFactor，当 loadFactor<=1 时，hash 表查找的期望复杂度为 O(1). 因此，每次往 hash 表中添加元素时，我们必须保证是在 loadFactor <1 的情况 下，才能够添加。当 Hash 表中 loadFactor==1 时，Hash 就需要进行 rehash。

rehash 过程中，会模仿C++的 vector 扩容方式，Hash 表中每次发现 loadFactor ==1 时，就开辟一个原来桶数组的两倍 空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。

### 请你说一下哈希表的桶个数为什么是质数

 哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。
如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。

### 哈希表解决冲突的方法

* 开放定址 

  开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过 1。 它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地 址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找 到一个为空的地址为止。所以这种方法又称为再散列法。
  有几种常用的探查序列的方法：

  ①线性探查 dii=1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。 

  ②二次探查 di=12，-12，22，-22，…，k2，-k2 ( k<=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。 

  ③ 伪随机探测 di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如 i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。 

* 链地址 

* ![C++面试_数据结构与算法_1.jpg](/images\C++面试_数据结构与算法_1.jpg)

  每个位桶实现的时候，采用链表或者树的数据结构来去存取发生哈希冲突的输入域的关键字，也就是被哈希函数映射到同一个位桶上的关键字。 紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的 key 映射到了数组的同一位置处，就将其放入单链表中，即链 接在桶后。

* 公共溢出区 建立一个公共溢出区域，把 hash 冲突的元素都放在该溢出区里。查找时，如果发现 hash
  表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。 

* 再 hash 再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。 

  缺点：每次冲突都要重新散列，计算时间增加。
  .

### 字符串哈希

来源：https://www.cnblogs.com/moyujiang/p/11213535.html	

#### 字符串哈希入门

说得通俗一点，字符串哈希实质上就是**把每个不同的字符串转成不同的整数**。

为什么会有这样的需要呢？很明显，存储一个超长的字符串和存储一个超大但是能存的下的整数，后者所占的空间会少的多，但主要还是为了方便**判断一个字符串是否出现过**，这是最基础的部分。

当然也很容易想到，如果有不同的字符串转成同一个整数，那么区分功能就基本废掉 ，所以我们需要一个算法把每个字符串转成**唯一的**整数。所以字符串哈希算法就应运而生，哈希算法的难点也就在于如何构造一个合适的Hash函数来满足我们的需求。

下面就简单介绍几种字符串哈希的基本方法。

#### 基本哈希方法

一般地，给定一个字符串 S=s1s2s3s4...snS=s1s2s3s4...sn，令idx(x)=x−′a′+1idx(x)=x−′a′+1，当然，直接(int)x（用它的ASCll码）也一样。

### 自然溢出法

这种方法是利用数据结构`unsigned long long`的范围自然溢出：即当存储的数据大于`unsigned long long`的存储范围时，会自动mod 264−1264−1，就不用mod其他质数来保证唯一性了。

### Hash公式

```
unsigned long long Hash[n]
hash[i]=hash[i−1]∗p+idx(s[i]);
```

注意：这里的p一定要是个质数，不然可能无法保证唯一性。

#### 单Hash法

相当于自然溢出法没有了自动取模的操作，所以需要自己进行取模操作。但是这种Hash方法在模数较小的时候的稳定性不一定得到保证，所以在这个方面不如其他方法。

### Hash公式

```
hash[i]=(hash[i−1])∗p+idx(s[i])%mod;
```

注意：这里的pp和modmod都是质数，且满足p<modp<mod。最好在选取的时候把pp和modmod的值取大一点。

##### 举例

如取p=13,mod=101p=13,mod=101，对字符串abcabc进行Hash

```
hash[0]=1;
hash[1]=(hash[0] × 13 + 2)%101=15;
hash[2]=(hash[1] × 13 + 3)%101=97;
```

所以最终字符串abcabc的hash值就是97

#### 双Hash法

> 其实网上很多博客讲了多Hash，但我觉得双Hash已经足够稳定了，再多一些也只是浪费时间而已。

顾名思义，双Hash就是对一个hash值用两个不同的质数进行两次modmod操作，然后最后用一对数<hash1[n],hash2[n]><hash1[n],hash2[n]>来表示一个字符串的哈希值，这样的一对数的重复几率加上选择较大的质数，冲突率几乎为0。

#### Hash方法

```
hash1[i]=(hash1[i−1])∗p+idx(s[i]) % mod1
hash2[i]=(hash2[i−1])∗p+idx(s[i]) % mod2
```

**这样的哈希很安全**

#### Hash素数的选择

为了防止冲突，要选择合适的素数，像1e9+7,1e9+9的一些素数，出题人一般会卡一下下，所以尽量选择其他的素数，防止被卡。下面是一些可供选择的素数。
上界和下界指的是离素数最近的2n2n的值。

|      |      |           |            |
| ---- | ---- | --------- | ---------- |
| lwr  | upr  | % err     | prime      |
| 2^5  | 2^6  | 10.416667 | 53         |
| 2^6  | 2^7  | 1.041667  | 97         |
| 2^7  | 2^8  | 0.520833  | 193        |
| 2^8  | 2^9  | 1.302083  | 389        |
| 2^9  | 2^10 | 0.130208  | 769        |
| 2^10 | 2^11 | 0.455729  | 1543       |
| 2^11 | 2^12 | 0.227865  | 3079       |
| 2^12 | 2^13 | 0.113932  | 6151       |
| 2^13 | 2^14 | 0.008138  | 12289      |
| 2^14 | 2^15 | 0.069173  | 24593      |
| 2^15 | 2^16 | 0.010173  | 49157      |
| 2^16 | 2^17 | 0.013224  | 98317      |
| 2^17 | 2^18 | 0.002543  | 196613     |
| 2^18 | 2^19 | 0.006358  | 393241     |
| 2^19 | 2^20 | 0.000127  | 786433     |
| 2^20 | 2^21 | 0.000318  | 1572869    |
| 2^21 | 2^22 | 0.000350  | 3145739    |
| 2^22 | 2^23 | 0.000207  | 6291469    |
| 2^23 | 2^24 | 0.000040  | 12582917   |
| 2^24 | 2^25 | 0.000075  | 25165843   |
| 2^25 | 2^26 | 0.000010  | 50331653   |
| 2^26 | 2^27 | 0.000023  | 100663319  |
| 2^27 | 2^28 | 0.000009  | 201326611  |
| 2^28 | 2^29 | 0.000001  | 402653189  |
| 2^29 | 2^30 | 0.000011  | 805306457  |
| 2^30 | 2^31 | 0.000000  | 1610612741 |

#### 获取子串的hash

如果我们求出一个串的Hash，就可以O(1)O(1)求解其子串的Hash值。
公式的推导太复杂...干脆直接贴上来 （绝对不是我想偷懒）

#### 公式

若已知一个|S|=n|S|=n的字符串的hash值，hash[i]hash[i],1≤i≤n1≤i≤n，其子串sl..sr,1≤l≤r≤nsl..sr,1≤l≤r≤n，对应的hash值为：

$$hash=((hash[r]−hash[l−1]∗pr−l+1)%mod+mod)%modhash=((hash[r]−hash[l−1]∗pr−l+1)%mod+mod)%mod$$