# 计算机网络

## TCP

传输控制协议 TCP（Transmission Control Protocol）

是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。

* * 

### TCP报文首部

![image-20200719140800741](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_4.jpg)

* 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；
* 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
* 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
* 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
* 保留，占6位，保留今后使用，但目前应都位0；
* 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
* 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
* 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
* 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
* 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
* 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
  窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
* 检验和，占2字节，校验首部和数据这两部分；
* 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；
* 选项，长度可变，定义一些其他的可选的参数。

### TCP 断开与连接过程

```sequence
title: TCP连接与断开过程
participant Client
participant Server
Client-->>Server:建连接三次握手
Note left of Client:SYN_SENT\n(connect())
Client->Server: SYN seq=x
Note right of Server: LISTEN\n(listen())
Note right of Server: SYN_RCVD
Server->Client:SYN seq=y ack=x+1
Note left of Client:ESTABLISHED
Client->Server: ACK = y+1
Note right of Server:ESTABLISHED

Client--Server: 数据传输
Note left of Client:(write())
Client->Server: seq = x+1 ACK=y+1
Note right of Server: (read())
Server->Client:ACK+2

Client-->Server: 断连接四次握手
Note left of Client:FIN_WAIT_1\n(close())
Client->Server: FIN seq=x+2 ACK =y+1
Note right of Server: CLOSE_WAIT
Note right of Server: LAST_ACK\n(close())
Server->Client:ACK x+3
Server->Client:FIN seq= y+1
Note left of Client:FIN_WAIT_2
Note left of Client:TIME_WAIT
Client->Server: ACK = y+2
```

![image-20200718164617624](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_1.jpg)

#### 什么是三次握手

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。

TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。

TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接；采用四次挥手来关闭一个连接。

一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。

当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会（提供网络利用率这部分有讲到）。

ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。

**一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。**

序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而IP 不提供重复消除或者保证次序正确的功能。

另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

#### 三次握手：

1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入 SYN_SENT 状态，等待 Server 确认。
2. Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立连接，Server 将标志位 SYN和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给 Client 以确认连接请 求，Server 进入 SYN_RCVD 状态。
3. Client 收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACK 置为1，ack=K+1，并将该数据包发送给 Server，Server 检查 ack 是否为 K+1，ACK 是否为 1，如果正 确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。

#### **为什么三次？**

1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

2、换个易于理解的视角来看为什么要 3 次握手。

客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。

而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

**每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？**

而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。

其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。

比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。

#### 四次挥手：

 由于 TCP 连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没 有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向 也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

1. 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1 状态，此时客户端依然可以接收服务器发送来的数据。 
2. 服务器接收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT 状态。客户端收到后进入 FIN_WAIT_2 状态。 
3. 当服务器没有数据要发送时，服务器发送一个 FIN 报文，此时服务器进入 LAST_ACK 状态，等待客户端的确认 
4. 客户端收到服务器的 FIN 报文后，给服务器发送一个 ACK 报文，确认序列号为收到的序号+1。此时客户端进入 TIME_WAIT 状态，等待 2MSL（MSL：报文段最大生存时间），然后关闭连接

#### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

1、TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。

**2、这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。**

注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。

#### 精炼版

三次握手 

1. 客户端发送 syn0 给服务器 

2. 服务器收到 syn0，回复 syn1,ack(syn0+1) 
3. 客户端收到 syn1，回复 ack(syn1+1) 

四次挥手(这里以客户端主动断开为例) 

1. 客户端发送 fin 
2. 服务端收到 fin,回复 ack,然后服务器去处理其他事 
3. 服务器事情处理完，回复 fin 
4. 客户端回复 ack 

为什么用三次握手 

本来握手应该和挥手一样都是需要确认两个方向都能联通的，

本来模型应该是： 

	1. 客户端发送 syn0 给服务器 
 	2. 服务器收到 syn0，回复 ack(syn0+1) 
 	3. 服务器发送 syn1 
 	4. 客户端收到 syn1，回复 ack(syn1+1) 

因为 tcp 是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是 2，3 步 没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了 3 步握手。



> 按我的理解说一下3次握手跟4次挥手 
>
> 3次握手就跟早期打电话时的情况一样：1、听得到吗？2、听得到，你呢？3、我也听到了。然后才开始真正对话 
>
> 4次挥手是：1、老师，下课了。2、好，我知道了，我说完这点。3、好了，说完了，下课吧。4、谢谢老师，老师再见

### 四层TCP/IP模型
|层|协议|
|---|---|
| 应用层 | Telenet FTP e-mail HTTP DNS SMTP|
| 传输层 | TCP 和 UDP           |
| 网络层 | IP/ARP/ICMP/IGMP         |
| 链路层 | MAC/VLAN |

![](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_2.jpg)



### TCP可靠性

* **序列号、确认应答、超时重传**

  数据到达接收方，接收方需要发出一个确认应答、标识已经收到该数据段。并确认序号会说明下一次需要接受的数据序列号。

  如果发送方迟迟未收到确认应答，那么可能事发送的数据丢失，也可能事确认应答丢失，这时候发送发会在等待一定时间后重传。

  这个时间一般是 **2*RTT(报文段往返时间)+一个偏差值**

* **窗口控制与告诉冲法控制/快速重传(重复确认应答)**

  TCP会利用窗口控制来提高传输速度。在一个窗口大小内不一定要能到应答才发送下一段数据，窗口大小事无需等待确认可以继续发送数据的最大值。如果不使用窗口控制，则每一个没收到确认的应答的数据都要重新发送。

  使用窗口控制，如果数据段 1001-2000 丢失，后面数据每次传输，确认应答都会不停地发送序号为 1001 的应答，表示我要接收 1001 开始的数据，发送端如果收到 3 次相同应答，就会立刻 进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发， 因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......


### **拥塞控制**

如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以 TCP 在为了防止这种情 况而进行了拥塞控制。

* **慢启动**：定义拥塞窗口，一开始将该窗口大小设为 1，之后每次收到确认应答（经过一个 rtt），将拥塞窗口大小*2。

* ![image-20200719142511286](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_5.jpg) 

* **拥塞避免**：设置慢启动阈值，一般开始都设为 65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个 rtt，拥塞窗口大小 +1），以此来避免拥塞。

  将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值 1，然后重新进入慢启动过程。 

* **快速重传**：在遇到 3 次重复确认应答（高速重发控制）时，代表收到了 3 个报文段，但是这之前的 1 个段丢失了，便对它进行立即重传。 

  然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3 的大小。 

  这样可以达到：在 TCP 通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。

  ![image-20200719142557026](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_6.jpg)

###  TCP 短连接和长连接的区别

**短连接：**Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。

短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

**长连接：**Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。

长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。

### TCP粘包、拆包及解决办法

#### 为什么常说 TCP 有粘包和拆包的问题而不说 UDP 

由前两节可知，UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。

#### 粘包、拆包

假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：

第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。

![img](https://pic4.zhimg.com/v2-1f03c5a6c04279d9c318ef48348dc32d_r.jpg)

第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

![img](https://picb.zhimg.com/v2-e090a51ff37d6dfd1de747c70288222a_r.jpg)

第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。



![img](https://pic1.zhimg.com/v2-6163805a4cbd6be0581cca82cd5ac8f5_r.jpg)

![img](https://picb.zhimg.com/v2-ca1d6c986cec845951dd0811f5888021_r.jpg)

##### TCP 粘包、拆包原因

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

##### 粘包、拆包解决办法

由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：

- **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
- **将消息分为消息头和消息体：**消息头中包含表示消息总长度（或者消息体长度）的字段。
- 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。

### TCP/IP 数据链路层的交互过程

网络层等到数据链层用 mac 地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，

首先会去自己的 arp 缓存表(存着 ip-mac 对应关系)去查找改目标 ip 的 mac 地址，如果查到了，就讲目标 ip 的 mac 地址封装到链路层数据包的包头。

如果缓存中没有找到，会发起一个广 播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个 ip 是不是自己的，如果是自己 的，则以单拨的形式将自己的 mac 地址回复给请求的机器

###  IP 层对应给哪个应用程序，区分TCP和UDP

根据端口区分

看 ip 头中的协议标识字段，17 是 udp，6 是 tcp

## 提供网络利用率

* Nagle 算法

  发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。

  * 已发送的数据都已经收到确认应答。
  * 可以发送最大段长度的数据时。

* 延迟确认应答

  接收方收到数据之后可以并不立即返回确认应答，而是延迟一段时间的机制。

  * 在没有收到 2*最大段长度的数据为止不做确认应答。
  * 其他情况下，最大延迟 0.5秒 发送确认应答。
  * TCP 文件传输中，大多数是每两个数据段返回一次确认应答。

* 捎带应答

  在一个 TCP 包中既发送数据又发送确认应答的一种机制，由此，网络利用率会提高，计算机的负荷也会减轻，但是这种应答必须等到应用处理完数据并将作为回执的数据返回为止。

## UDP

用户数据报协议 UDP（User Datagram Protocol

是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信



### UDP首部

UDP 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

![image-20200719135948906](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_3.jpg)

### UDP connect函数

除非套接字已连接，否则异步错误是不会返回到 UDP 套接字的。我们确实可以给 UDP 套接字
调用 connect，然而这样做的结果却与 TCP 连接不同的是没有三路握手过程。内核只是检查是否 存在立即可知的错误，记录对端的 IP 地址和端口号，然后立即返回调用进程。

对于已连接 UDP 套接字，与默认的未连接 UDP 套接字相比，发生了三个变化。 其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个 UDP 连接传输数据的性质还是不变的，仍然是不可靠的 UDP 连接。一旦变成一对一 的连接，在调用系统调用发送和接受数据时也就可以使用 TCP 那一套系统调用了。

1. 我们再也不能给输出操作指定目的 IP 地址和端口号。也就是说，我们不使用 sendto， 而改用 write 或 send。写到已连接 UDP 套接字上的任何内容都自动发送到由 connect 指定的协议地址。可以给已连接的 UDP 套接字调用 sendto，但是不能指定目的地址。sendto 的第五个参 数必须为空指针，第六个参数应该为 0.
2. 不必使用 recvfrom 以获悉数据报的发送者，而改用 read、recv 或 recvmsg。在一个已
   连接 UDP 套接字上，由内核为输入操作返回的数据报只有那些来自 connect 指定协议地址的数据 报。这样就限制一个已连接 UDP 套接字能且仅能与一个对端交换数据报。
3. 由已连接 UDP 套接字引发的异步错误会返回给它们所在的进程，而未连接的 UDP 套接字
   不接收任何异步错误。 来自任何其他 IP 地址或断开的数据报不投递给这个已连接套接字，因为它们要么源 IP 地址要么源 UDP 端口不与该套接字 connect 到的协议地址相匹配。 UDP 客户进程或服务器进程只在使用自己的 UDP 套接字与确定的唯一对端进行通信时，才可以调用 connect。调用 connect 的通常是 UDP 客户，不过有些网络应用中的 UDP 服务器会与单个 客户长时间通信 TFTP，这种情况下，客户和服务器都可能调用 connect。

## TCP 和UDP 应用场景

\|TCP|UDP
---|---|---
连接|TCP是面向传输层的协议 传输数据前必须建立好连接|UDP无连接
服务对象|点对点的两点服务，一条TCP 只能有两个端点|UDP 支持多对多的交互通信。
可靠性|TCP 是可靠交付：无差错，不丢失，不重复，按序到达。| UDP 是尽最大努力交付，不保证可靠交付。
拥塞与流量控制|TCP 有拥塞控制和流量控制保证数据传输的安全性。|UDP 没有拥塞控制，网络拥塞不会影响源主机的发送效率。
## HTTP和HTTPS

### 定义

HTTP 协议： HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。
HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）。
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW
中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG（Next
Generation of HTTP）的建议已经提出。
HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端
即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。

### HTTP 协议特点

* 简单快速：
  客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
  每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规
  模小，因而通信速度很快。
* 灵活：
  HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
* 无连接：
  无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应
  答后，即断开连接。采用这种方式可以节省传输时间。
* 无状态：
  HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如
  果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
* 支持 B/S 及 C/S 模式。
* 默认端口 80
* 基于 TCP 协议

### HTTP 过程概述：

* HTTP 协议定义 
  * Web 客户端如何从 Web 服务器请求 Web 页面
  * 以及服务器如何把 Web 页面传送给客户端。
  * HTTP 协议采用了请求/响应模型。
  * 客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。
  * 服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。
* HTTP 请求/响应的步骤如下：

1. 客户端连接到 Web 服务器一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP套接字连接。例如，http://www.baidu.com。 
2. 发送 HTTP 请求 通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。 
3. 服务器接受请求并返回 HTTP 响应 Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。 
4. 释放连接 TCP 连接 若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP连接;若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请 求;
5. 客户端浏览器解析 HTML 内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根 据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。

#### 举例

 在浏览器地址栏键入 URL，按下回车之后会经历以下流程： 

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址； 

2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接； 

3. 浏览器发出读取文件（URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为
   TCP 三次握手的第三个报文的数据发送给服务器；
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
5. 释放 TCP 连接； 
6. 浏览器将该 html 文本并显示内容；

### HTTP 返回码

* 1xx：指示信息--表示请求已接收，继续处理。 
* 2xx：成功--表示请求已被成功接收、理解、接受。 
* 3xx：重定向--要完成请求必须进行更进一步的操作。 
* 4xx：客户端错误--请求有语法错误或请求无法实现。 
* 5xx：服务器端错误--服务器未能实现合法的请求。 
* 常见状态代码、状态描述的详细说明如下。 
  * 200 OK：客户端请求成功。
  * 206 partial content 服务器已经正确处理部分 GET 请求，实现断点续传或同时分片下载，
    该请求必须包含 Range 请求头来指示客户端期望得到的范围 300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏
    览器/用户自行选择其中一个。 
  * 301moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该
    资源的访问都要使用本响应返回的若干个 URI 之一。
  *  302 move temporarily(临时重定向)：请求的资源现在临时从不同的 URI 中获得， 
  * 304：not modified :如果客户端发送一个待条件的 GET 请求并且该请求以经被允许，而文档内容未被改变，则返回 304,该响应不包含包体（即可直接使用缓存）。 
  * 403 Forbidden：服务器收到请求，但是拒绝提供服务。 
  * t Found：请求资源不存在，举个例子：输入了错误的 URL。

###  HTTP 和 HTTPS 区别

| HTTP             | HTTPS                      |
| ---------------- | -------------------------- |
| 明文方式网络传输 | 经过TLS加密后传输 安全性高 |
||HTTPS 在三次握手后还需要SSL的handshake协商加密使用的堆成加密密钥|
||HTTPS 需要服务端申请证书 浏览器安装对应根证书|
|协议端口为80|协议端口为443|

### HTTPS 优缺点

优点

* HTTPS 传输数据过程中使用密钥进行加密，所以安全性更高 

* HTTPS 协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

缺点： 

* HTTPS 握手阶段延时较高：由于在进行 HTTP 会话之前还需要进行 SSL 握手，因此 HTTPS 协
  议握手阶段延时增加 
* HTTPS 部署成本高：一方面 HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买 CA
  证书；
* 另一方面由于采用 HTTPS 协议需要进行加解密的计算，占用 CPU 资源较多，需要的服务器 配置或数目高

###  http 协议会话结束标志

看 tcp 连接是否有断开的四部挥手阶段

## 网络模型

### OSI 七层网络模型

OSI 七层模型及其包含的协议如下: 
层|描述|协议
---|---|---
物理层:|通过媒介传输比特,确定机械及电气规范,传输单位为 bit|IEE802.3 CLOCK RJ45 
数据链路层|将比特组装成帧和点到点的传递,传输单位为帧| MAC VLAN PPP 
网络层|负责数据包从源到宿的传递和网际互连，传输单位为包| IP ARP ICMP 
传输层|提供端到端的可靠报文传递和错误恢复，传输单位为报文| TCP UDP 
会话层|建立、管理和终止会话，传输单位为 SPDU|RPC NFS 
表示层|对数据进行翻译、加密和压缩,传输单位为 PPDU|主要包括的协议为 JPEG ASII
应用层| 允许访问 OSI 环境的手段,传输单位为 APDU|FTP HTTP DNS TCP/IP 

### [TCP/IP 四层模型](#四层TCP/IP模型)

## 实例

### 搜索 baidu，会用到计算机网络中的什么层？每层是干什么的

浏览器中输入 URL 浏览器要将 URL 解析为 IP 地址，

解析域名就要用到 DNS 协议，首先主机会查询 DNS 的缓存，如果没有就给本地 DNS 发送查询请求。DNS 查询分为两种方式，一种是递归查询，一种是迭代查 询。如果是迭代查询，本地的 DNS 服务器，向根域名服务器发送查询请求，根域名服务器告知该 域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到 查询到该域名的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。
得到 IP 地址后，浏览器就要与服务器建立一个 http 连接。http 生成一个 get 请求报文，将该报文传给 TCP 层处理，所以还会 用到 TCP 协议。如果采用 https 还会使用 https 协议先对 http 数据进行加密。TCP 层如果有需 要先将 HTTP 数据包分片，分片依据路径 MTU 和 MSS。

TCP 的数据包然后会发送给 IP 层，用到 IP 协议。IP 层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网 协议实现(也可以是其他物理层协议，比如 PPP，SLIP)，以太网协议需要直到目的 IP 地址的物 理地址，有需要 ARP 协议。其中： 

1、DNS 协议，http 协议，https 协议属于应用层 应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还 要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功 能。应用层直接为用户的应用进程提供服务。
2、TCP/UDP 属于传输层 传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议 TCP，和无连接的用户数据报协议 UDP。面向连接的服务能够提供可 靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方 式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。
3、IP 协议，ARP 协议属于网络层 网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在 TCP/IP 体系中，分组也叫作 IP 数据报，或简称 为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交 付到目的主机。

 4、数据链路层当发送数据时，数据链路层的任务是将在网络层交下来的 IP 数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址 信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和 到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。

 5、物理层物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此 也有人把物理媒体当做第 0 层。

```flow
st=>start: 输入URL
DNS=>operation: 使用DNS解析地址
DNSTEMP=>condition: 是否有DNS 缓存
DNS_HD=>condition: 查询方式
基于UDP
DNS_DG=>operation: 递归查询\n
DNS_DD=>operation: 迭代查询
一开始向根服务器查询 
逐步向子级查询IP
IP_GET=>operation: 获得IP地址
IP_GET2=>operation: 获得IP地址
st()->DNS->DNSTEMP
DNSTEMP(yes)->IP_GET
DNSTEMP(no,bottom)->DNS_HD
DNS_HD(yes)->DNS_DD(bottom)->IP_GET
DNS_HD(no)->DNS_DG(bottom)->IP_GET

HTTP=>operation: 建立HTTP连接
HTTP_GET=>operation: 生成get报
给TCP层处理
HTTPS=>operation: HTTPS对数据进行加密
TCP=>condition: 是否需要对HTTP数据包分片
TCP_SP=>operation: 依据路径MTU和MSS
IP_L=>operation: 一跳一跳发送到目的地址
以太网协议网段内的寻址
以太网协议需要直到目的IP地址的物理地址
需要ARP 协议。

IP_GET->HTTP->HTTP_GET
HTTP_GET->HTTPS->TCP
TCP(yes,right)->TCP_SP->IP_L
TCP(no,left)->IP_L


```

## socket

### socket 开发过程

服务端：socket-bind-listen-accept
客户端：socket-connect

### socket 编程中服务器端和客户端主要用的函数

#### 基于 TCP 的 socket 

* 服务器端程序： 
  1. 创建一个 socket，用函数 socket() 
  2. 绑定 IP 地址、端口等信息到 socket 上，用函数 bind()
  3. 设置允许的最大连接数，用函数 listen() 
  4. 接收客户端上来的连接，用函数 accept() 
  5. 收发数据，用函数 send()和 recv()，或者 read()和 write()
  6. 关闭网络连接 
* 客户端程序： 
  1. 创建一个 socket，用函数 socket() 
  2. 设置要连接的对方的 IP 地址和端口等属性 
  3. 连接服务器，用函数 connect() 
  4. 收发数据，用函数 send()和 recv()，或 read()和 write()
  5.  关闭网络连接

![image-20200720154442429](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_7.jpg)

### 基于UDP

* 服务器端流程 
  * 建立套接字文件描述符，使用函数 socket()，生成套接字文件描述符。 
  * 设置服务器地址和侦听端口，初始化要绑定的网络地址结构。
  * 绑定侦听端口，使用 bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。 
  * 接收客户端的数据，使用 recvfrom()函数接收客户端的网络数据。 
  * 向客户端发送数据，使用 sendto()函数向服务器主机发送数据。 
  * 关闭套接字，使用 close()函数释放资源。
* 客户端流程 
  * 建立套接字文件描述符，socket()。
  * 设置服务器地址和端口，struct sockaddr。 
  * 向服务器发送数据，sendto()。
  * 接收服务器的数据，recvfrom()。
  * 关闭套接字，close()。

![image-20200720155426132](E:\Notes\MarkDown\计算机课程学习\imgs\C++面试_计算机网络_8.jpg)

### 函数

* send 函数用来向 TCP 连接的另一端发送数据。客户程序一般用 send 函数向服务器发送请求，而 服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区， 协议负责传输。 
* recv 函数用来从 TCP 连接的另一端接收数据，当应用程序调用 recv 函数时，recv 先等待 s 的发 送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。 
* accept 函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的 时候，accept 函数阻塞，不为空的时候 accept 函数从上边取下来一个已完成连接，返回一个文 件描述符。

## 数字证书

### 概念

 数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系 的基础。在用户使用数字证书之前必须首先下载和安装。
认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心 提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。

### 数字证书颁发过程

数字证书颁发过程如下：

1. 用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。
2. 认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送 而来，
3. 然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还 附有对认证中心公共密钥加以确认的数字证书。
4. 当用户想证明其公开密钥的合法性时，就可以提 供这一数字证书。

### 内容

数字证书的格式普遍采用的是 X.509V3 国际标准，一个标准的 X.509 数字证书包含以下一些
内容： 

1. 证书的版本信息； 
2. 证书的序列号，每个证书都有一个唯一的证书序列号； 
3. 证书所使用的签名算法； 
4. 证书的发行机构名称，命名规则一般采用 X.500 格式； 
5. 证书的有效期，通用的证书一般采用 UTC 时间格式；
6. 证书所有人的名称，命名规则一般采用 X.500 格式； 
7. 证书所有人的公开密钥； 
8. 证书发行者对证书的签名。

## 阻塞与同步

### 阻塞和非阻塞

调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是 阻塞。

调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。

### 同步和异步

调用者必须循环自去查看事件有没有发生，这种情况是同步。

调用者不用自己去查 看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步。