## map和set区别和实现

  * map

    * key-value 全剪子起到索引的作用 值则标识与相关联的数据
    * 允许修改value
    * 支持下标,下标修改value
      *  如果key 不存在 则创建一个关键码和一个默认值
      * const_map不能使用
      * 尽可能用find

  * set 

    * 关键字的简单集合

    * 迭代器是const 不能修改元素。

      > 其原因是因为 map 和 set 是根据关键字排序来保证其有序性的,如果允许修改 key 的话, 那么首先需要删除该键,然后调节平衡,再插入修改后的键值,调节平衡,如此一来,严重破坏 了 map 和 set 的结构,导致 iterator 失效,不知道应该指向改变前的位置,还是指向改变后的 位置。所以 STL 中将 set 的迭代器设置成 const,不允许修改迭代器的值;

    * 不支持下标

## STL allocaotr  

  * STL 分配器用于封装STL 再内存管理上的底层细节
  * new分为两阶段 
    * 调用::operator new 配置内存;
    * 调用对象构造函数构造对象内容
  * delete 运算分两个阶段
    * 调用对象析构函数
    *  调用::operator delete 释放内存

  * 采用两继配置器
    * 小于128B 时会使用第一级空间配置器 使用malloc,remalloc ,free来管理内存
    * 大于128B 则采用内存池 二号空闲链来管理内存

## STL 迭代器删除元素

  * 对于序列容器 vector,deque 来说,使用erase(itertor)后,后边的每个元素的迭代器都会失效,但是后边每个元素都会往前移动一个位 置,但是 erase 会返回下一个有效的迭代器;
  *  对于关联容器 map set 来说,使用了 erase(iterator)后,当前元素的迭代器失效,但是其结构是红黑树,删除当前元素的,不会影 响到下一个元素的迭代器,所以在调用 erase 之前,记录下一个元素的迭代器即可。
  * 对于 list 来说,它使用了不连续分配的内存,并且它的 erase 方法也会返回下一个有效的 iterator,因 此上面两种正确的方法都可以使用。

## STL MAP 数据存放

* 形式为红黑树。
* unordered_map 为哈希表

## STL 基本组成:

* 容器 迭代器 仿函数 算法 分配器 配接器

  * 分配器给容器分配存储空间
  * 算法通过迭代器获取容器中的内容
  * 仿函数可以 协助算法完成各种操作
  * 配接器用来套接适配仿函数

## map 和 multimap

  * Map 映射,map 的所有元素都是 pair,同时拥有实值(value)和键值(key)。pair 的第一元素被视为键值,第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值 重复。

    * 底层实现:红黑树

    *  适用场景:有序键值对不重复映射 

  * Multimap 多重映射。multimap 的所有元素都是 pair,同时拥有实值(value)和键值(key)。pair的第一元素被视为键值,第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许 键值重复。

    * 底层实现:红黑树 
    * 适用场景:有序键值对可重复映射	

## vector和list

  * Vector 连续存储的容器,动态数组,

    * 在堆上分配空间 

    * 底层实现:数组 两倍容量增长: 

      vector 增加(插入)新元素时,如果未超过当时的容量,则还有剩余空间,那么直接添加到最后(插入指定位置),然后调整迭代器。 如果没有剩余空间了,则会重新配置原有元素个数的两倍空间,然后将原空间元素通过复制的方式初始化新空间,再向新空间增加元素,最后析构并释放原空间,之前的**迭代器会失效**。 

    * 性能:
      * 访问: O(1)
      * 插入:在最后插入(空间够):很快
        在最后插入(空间不够):需要内存申请和释放,以及对之前数据进行拷贝。
        在中间插入(空间够):内存拷贝
        在中间插入(空间不够):需要内存申请和释放,以及对之前数据进行拷贝。
      * 删除:在最后删除:很快
      * 在中间删除:内存拷贝
      * 适用场景:经常随机访问,且不经常对非尾节点进行插入删除。

  * List 动态链表,在堆上分配空间,每插入一个元数都会分配空间,每删除一个元素都会释放空间。

    * 底层:双向链表

    * 性能:

      * 访问:随机访问性能很差,只能快速访问头尾节点。

      * 插入:很快,一般是常数开销
      * 删除:很快,一般是常数开销
      * 适用场景:经常插入删除大量数据

  * 区别:

    * vector 底层实现是数组;list 是双向 链表。
    * vector 支持随机访问,list 不支持。
    * vector 是顺序内存,list 不是。
    * vector 在中间节点进行插入删除会导致内存拷贝,list 不会。
    * vector 一次性分配好内存,不够时才进行 2 倍扩容;list 每次插入新节点都会进行内
      存申请。
    * vector 随机访问性能好,插入删除性能差;list 随机访问性能差,插入删除性能好。

  * 应用

    * vector 拥有一段连续的内存空间,因此支持随机访问,如果需要高效的随即访问,而不在乎插入和删除的效率,使用 vector。 
    * list 拥有一段不连续的内存空间,如果需要高效的插入和删除,而不关心随机访问,则应使用 list。

## STL 迭代器

  * 迭代器 Iterator(迭代器)模式又称 Cursor(游标)模式,用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解:Iterator 模 式是运用于聚合对象的一种模式,通过运用该模式,使得我们可以在不知道对象内部表示的情况 下,按照一定顺序(由 iterator 提供的方法)访问聚合对象中的各个元素。由于 Iterator 模式的以上特性:与聚合对象耦合,在一定程度上限制了它的广泛运用,一般仅用于底层聚合支持类,如 STL 的 list、vector、stack 等容器类及ostream_iterator 等扩 展 iterator。
  * 迭代器和指针的区别 迭代器不是指针,是**类模板**,表现的像指针。他只是模拟了指针的一些功能,通过重载了指针的一些操作符,->、*、++、--等。迭代器封装了指针,是一个"可遍历 STL( Standard Template Library)容器内全部或部分元素"的对象, 本质是封装了原生指针,是指针概念的一种提升(lift),提供了比指针更高级的行为,相当于一种智能指针,他可以根据不同类型的数据结构 来实现不同的++,--等操作。迭代器返回的是对象引用而不是对象的值,所以 cout 只能输出迭代器使用*取值后的值而不能直接输出其自身。
  * 迭代器产生原因 Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来,使得不用暴露集合内部的结构而达到循环遍历集合的效果。

## epoll 是一个可扩展的 Linux I/O 事件通知机制。

  * [epoll详解](https://zhuanlan.zhihu.com/p/63179839)

  int epoll_create(int size); i

  nt epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
  int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout); 

  首先创建一个 epoll 对象,然后使用 epoll_ctl 对这个对象进行操作,把需要监控的描述添加进去,这些描述如将会以epoll_event结构体的形式组成一颗红黑树,接着阻塞在epoll_wait, 进入大循环,当某个 fd 上有事件发生时,内核将会把其对应的结构体放入到一个链表中,返回 有事件发生的链表。



> n 个整数的无序数组,找到每个元素后面比它大的第一个数,要求时间复杂度为 O(N) -> 用栈

## resize和reverse

  * resize => 改变元素的数量 如果原来的小于更新后的 则新增元素默认初始化  再次调用push_back 的时候 放在原度末尾 下标为len 此时容器长度为len+1

  * reserve():改变当前容器的最大容量 但不会生成元素 只是确定容器允许放多少个对象 如果大于当前的capacity() 则会重新分配一个能存入len个对象的空间 然后 再拷贝