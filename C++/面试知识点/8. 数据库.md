# 数据库

## 事务

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务是 DBMS 中最基础的单位，事务不可分割。

### 基本特征【ACDI】

#### 原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 

#### 一致性（Consistency）

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 

> 拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致 性。

#### 隔离性（Isolation）

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在 并发地执行。
多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

##### 不同的隔离级别：

* Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，
  一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。 
* Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。
  可以解决脏读问题。 
* Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
*  Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。 

#### 持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 

例如我们在使用 JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题， 也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因 为故障而没有执行事务的重大错误。

## 三大范式

一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的三大范式，

* 第一范式要求确保表中每列的原子性，也就是不可拆分；
* 第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；
* 第三范式确保主键列之间没有传递函数依赖关系，也就是消除传递依赖。

## 索引

数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列
的值进行**排序**的一种结构。 

DB 在执行一条 Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到 特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。

### 优点： 

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 
3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
5.  通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

### 缺点： 

1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如
   果要建立聚簇索引，那么需要的空间就会更大
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的
   维护速度。 

### 添加索引原则

* 在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速 度和增大了空间需求。
* 只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的 数据行的比例很大。增加索引，并不能明显加快检索速度。

* 定义为 text、image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要
  么相当大，要么取值很少。 
* 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。**当增加索引时，会提高检索性能，但是会降低修改性能**。当减少索引时，会提高修改 性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

## join

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录

right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录 

inner join(等值连接) 只返回两个表中联结字段相等的行

# MYSQL

## 四种隔离状态

Mysql默认的事务隔离级别是**可重复读(Repeatable Read)**

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted)  | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（read-committed）   | 否   | 否         | 是   |
| 串行化                       | 否   | 否         | 否   |

* **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

* **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

* **幻读**：类似于不可重复读，都是在一个事务周期内读的数据不一致，区别在于幻读是侧重于插入操作带来的影响，而不可重复读是编辑或者删除带来的影响

  系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

## MVCC

MVCC 是一种多版本并发控制机制是.MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方
式，用于实现**提交读和可重复读**这两种隔离级别。

MVCC 是通过保存数据在某个时间点的快照来 实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号， 然后 Innodb 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行所有 快照连接起来。

## 优化

通过建立索引对查询进行优化 

对查询进行优化，应尽量避免全表扫描

## 引擎

### MySQL 引擎

#### 简介

MySQL 中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不 同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。
数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并
快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎 创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于 查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。
MySQL 存储引擎主要有： 

MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated 、Mrg_Myisam。 

但是最常用的是 InnoDB 和 Mylsam。 

#### InnoDB 

* InnoDB 是一个事务型的存储引擎，有行级锁定和外键约束。 
* Innodb 引擎提供了对数据库 **ACID** 事务的支持，并且实现了 SQL 标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。
* 该引擎还提供了行 级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于 MySQL 后台的完 整数据库系统，MySQL 运行时 Innodb 会在内存中建立缓冲池，用于缓冲数据和索引。
* 但是该引擎**不支持** FULLTEXT 类型的索引
* 它没有保存表的行数，当 SELECT COUNT(\*) FROM TABLE 时需要扫描全表。
* 当需要**使用数据库事务**时，该引擎当然是首选。
* 由于锁的粒度更小，写操作不会锁定全表，所以在**并发较高**时，使用 Innodb 引擎会提升效率。但是使用行级锁也不是绝对的， 如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表。
* 适用场景： 
  * 经常更新的表，适合处理多重并发的更新请求。 
  * 支持事务。
  *  可以从灾难中恢复（通过 bin-log 日志等）。 
  * 外键约束。只有他支持外键。 
  * 支持自动增加列属性 auto_increment。 
* 索引结构： 
  * InnoDB 也是 B+Treee 索引结构。Innodb 的索引文件本身就是数据文件，即 B+Tree 的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的 key 就是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。
  * InnoDB 的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查 找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以 Innodb 不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样 B+Tree 的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。

#### Mylsam

* MyIASM 是 MySQL **默认**的引擎，
* 它没有提供对数据库事务的支持
* 也不支持行级锁和外键，因此当 **INSERT 或 UPDATE 数据时**即写操作需要**锁定整个表**，效率便会低一些。
* MyIsam 存储引擎**独立于操作系统**，也就是可以在 windows 上使用，也可以比较简单的将数据转移到 linux操作系统上去。
* 适用场景：
  * 不支持事务的设计，但是并不代表着有事务操作的项目不能用 MyIsam 存储引擎，可以在
    service 层进行根据自己的业务需求进行相应的控制。
  * 不支持外键的表设计。
  * 查询速度很快，如果数据库 insert 和 update 的操作比较多的话比较适用。
  * 整天对表进行加锁的场景。
  * MyISAM 极度强调快速读取操作。
  * MyIASM 中存储了表的行数，于是 SELECT COUNT(*) FROM TABLE 时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么 MyIASM 也是很好的选择。
* 缺点：
  * 就是不能在表损坏后主动恢复数据。
* 索引结构：
  MyISAM 索引结构：MyISAM 索引用的 B+ tree 来储存数据，MyISAM 索引的指针指向的是键值的地址，地址存储的是数据。B+Tree 的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。

#### InnoDB 和 Mylsam 的区别：

1. **事务**：MyISAM 类型不支持事务处理等高级处理，而 InnoDB 类型支持，提供事务支持已
   经外部键等高级数据库功能。
2. **性能**：MyISAM 类型的表强调的是性能，其执行数度比 InnoDB 类型更快。
3. **行数保存**：InnoDB 中不保存表的具体行数，也就是说，执行 select count() fromtable时，InnoDB 要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count()语句包含 where 条件时，两种表的操作是一样的。
4. **索引存储**：对于 AUTO_INCREMENT 类型的字段，InnoDB 中必须包含只有该字段的索引，
   但是在 MyISAM 表中，可以和其他字段一起建立联合索引。MyISAM 支持全文索引（FULLTEXT）、压缩索引，InnoDB 不支持。MyISAM 的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而 Innodb 是索引和数据是紧密捆绑的，没有使用压缩从而会造成 Innodb 比 MyISAM 体积庞大不小。InnoDB 存储引擎被完全与 MySQL 服务器整合，InnoDB 存储引擎为在主内存中缓存数据和索
   引而维持它自己的缓冲池。InnoDB 存储它的表＆索引在一个表空间中，表空间可以包含数个文 件（或原始磁盘分区）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存在分离的文件中。 InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为 2GB 的操作系统上。
5. **服务器数据备份**：InnoDB 必须导出 SQL 来备份，LOAD TABLE FROM MASTER 操作对 InnoDB是不起作用的，解决方法是首先把 InnoDB 表改成 MyISAM 表，导入数据后再改成 InnoDB 表，但 是对于使用的额外的 InnoDB 特性(例如外键)的表不适用。
   MyISAM 应对错误编码导致的数据恢复速度快。MyISAM 的数据是以文件的形式存储，所以在
   跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 InnoDB 是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十 G 的时候就
   相对痛苦了。 
6. **锁的支持**：MyISAM 只支持表锁。InnoDB 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是 InnoDB 的行锁，只是在 WHERE 的主键是有效的，非主键的 WHERE 都会锁全表 的。

| 功能           | MyISAM                                                       | InnoDB                                                       |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事务           | 不支持事务灯高级处理                                         | 支持事务 外部键                                              |
| 性能           | 强调性能 速度快                                              |                                                              |
| 行数保存       | 保存具体行数  select count() 直接从内存中读取 但where时两个表是一样的 | 不保存具体行数  select count() 操作需要全表扫描 但where时两个表是一样的 |
| 索引储存       | AUTO_INCREMENT 字段 可以与其他字段一起简历来拟合索引<br>支持全文索引FULLTEXT<br>索引与数据分开 且索引有压缩的 内存效率高<br>每个表被存在分离的文件中 | AUTO_INCREMENT 字段 InnoDB必须包含只有该字段的索引<br>索引和数据捆绑 没有压缩 内存效率低<br>完全与服务器整合 拥有自身缓冲池<br>表和索引在一个表空间内 表空间一颗包含多个人间 表可以提时任何尺寸 |
| 服务器数据备份 | 对应错误编码导致恢复速度快 以文件形式储存 跨平台转移方便     | 必须导出SQL备份【可以先转成MyISAM 】                         |
| 锁             | 只支持表锁                                                   | 支持表锁和行锁 但行锁只是在WHERE的主键了有效 非主键的WHERE 会锁全表 |

# Redis

## monggodb 和 redis 区别

* 内存管理机制上

  * Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定
    的 LRU 算法删除数据。

  * MongoDB 数据存在内存，由 linux 系统 mmap 实现，当内存不够时，只 将热点数据放入内存，其他数据存在磁盘。

* 支持的数据结构上

  * Redis 支持的数据结构丰富，包括 hash、set、list 等。 
  * MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富

## Redis  定时机制

* Redis 服务器是一个**事件驱动程序**，处理两类事件
  * 文件事件（服务器对套接字操作的抽象）
  * 时间事件（服务器对定时操作的抽象）。

* Redis 的定时机制就是借助时间事 件实现的。一个时间事件主要由以下三个属性组成：
  * id：时间事件标识号；
  * when：记录时间事件的到达
    时间；
  * timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时 间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件

## Redis 数据类型

* 字符串：整数值、embstr 编码的简单动态字符串、简单动态字符串（SDS) 
* 列表：压缩列表、双端链表 
* 哈希：压缩列表、字典 
* 集合：整数集合、字典
* 有序集合：压缩列表、跳跃表和字典

## Redis rehash

因为 redis 是单线程，当 K 很多时，如果一次性将键值对全部 rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务。不可能一步完成整个 rehash 操 作，所以 redis 是分多次、渐进式的 rehash。

渐进性哈希分为两种：

* 操作 redis 时，额外做一步 rehash 对 redis 做读取、插入、删除等操作时，会把位于 table[dict->rehashidx]位置的链表移动到新的 dictht 中，然后把 rehashidx 做加一操作，移动到后面一个槽位。
* 后台定时任务调用 rehash 后台定时任务 rehash 调用链，同时可以通过 server.hz 控制 rehash 调用频率

## Redis 和 memcached 的区别

* 数据类型 ：
  * red`is 数据类型丰富，支持 set liset 等类型；
  * memcache 支持简单数据类型，需要客户端自己处理复杂对象 
* 持久性
  * redis 支持数据落地持久化存储；
  * memcache 不支持数据持久存储。
* 分布式存储：
  * redis 支持 master-slave 复制模式；
  * memcache 可以使用一致性 hash 做分布式
* value 大小不同：
  * memcache 是一个内存缓存，key 的长度小于 250 字符，单个 item 存储要小于 1M，不适合虚拟机使用
* 数据一致性不同：
  * redis 使用的是单线程模型，保证了数据按顺序提交；
  * memcache 需要使用 cas 保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁” 范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作
* cpu 利用
  * redis 单线程模型只能使用一个 cpu，可以开启多个 redis 进程