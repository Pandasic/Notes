
## 硬链接和软链接

* 好处:隐藏文件路径.增加权限安全及节省存储等好处
* 硬链接:同一个问价使用了不同的别名 使用ln创建
* 文件用户数据块中存放的内容是另一个文件的路径名指向 则该文件为软连接。软链接是个普通文件 有自己独立inode 文件内容比较特殊

## 大端 小端

[大端 小端](https://blog.csdn.net/qqliyunpeng/article/details/68484497) [联合体union 一个union代表多个类型 共享内存0](https://blog.csdn.net/u013066730/article/details/84638489)

* 大端是指低字节存储在高地址
* 小端存储是指低字节存储在低地址。
* 我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。

```C++
int fun()
{
    union test{int i;char c;}
    test t;t.i = 1;
    //如果是大端t.c 为0x00 t.c!=1 返回0
    //	  是小端他t.c的值为1 返回1
    return t.c==1;
}
```

## 静态变量 初始化

静态变量 储存在虚拟地址空间的数据段和BSS段

* C语言在代码执行前初始化 属于编译器初始化
* C++中由于引入对象,对象生成必须调用构造函数,因此 C++规定全局或局部 静态对象当且仅当对象首次用到时进行构造

## 用户态和内核态

操作系统的两种运行级别。

用户态拥有最低的特权级。运行在用户态的程序不能直接访问操作系统内核数据 结构和程序。

内核态拥有最高的特权级。

内核态和用户态之间的转换方式主要包括:系统调用,异常和中断。

## 内存溢出和内存泄漏

### 内存溢出

程序申请内存的时候 没有足够的内存供申请者使用。

内存溢出就是你要的内存空间超过了系统实 际分配给你的空间,此时系统相当于没法满足你的需求,就会报内存溢出的错误

产生的原因:

* 内存中加载的数据量过于庞大,如一次从数据库取出过多数据
* 集合类中有对对象的引用,使用完后未清空,使得不能回收
* 代码中存在死循环或循环产生过多重复的对象实体
* 使用的第三方软件中的 BUG
* 启动参数内存值设定的过小

### 内存泄漏

* 内存泄漏通常是由于调用了malloc/new等内存申请的操作,但是缺少了对应free/delete。为了**判断**内存是否泄露。
* 使用 linux 环境下的内存泄漏检查工具 Valgrind
* 我们在写代码时可以添加内存申请和释放的统计功能,统计当前申请和释放的内存是否一致, 以此来判断内存是否泄露。
* 分类
  * 堆内存泄漏:对内存指的是程序运行中根据需要分配通过 malloc,realloc,new 等从堆中分配的一块内存,再是完成后必须通过调用对应的 free 或者 delete 删掉。如果 程序的设计的错误导致这部分内存没有被释放,那么此后这块内存将不会被使用,就会产生 Heap Leak.
  * 系统资源泄漏:要指程序使用系统分配的资源比如Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉,导致系统资源的浪费,严重可导致系统 效能降低,系统运行不稳定。
  * 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时,如果基类的析构函
    数不是 virtual,那么子类的析构函数将不会被调用,子类的资源没有正确是释放,因此造成内 存泄露。

## 对于 C++源文件,从文本到可执行文件一般需要四个过程:

1. 预处理阶段:对源代码文件中文件包含关系(头文件).预编译语句(宏定义)进行分析和替换,生成预编译文件。

   主要处理源代码文件中的以"#"开头的预编译指令。处理规则见下

   1. 删除所有的#define,展开所有的宏定义
   2. 处理所有的条件预编译指令,如"#if"."#endif"."#ifdef"."#elif"和"#else"。
   3. 处理"#include"预编译指令,将文件内容替换到它的位置,这个过程是递归进行的,文件 中包含其他文件。
   4. 删除所有的注释,"//"和"/**/"。
   5. 保留所有的#pragma 编译器指令,编译器需要用到他们,如:#pragma once 是为了防止有文 件被重复引用。
   6. 添加行号和文件标识,便于编译时编译器产生调试用的行号信息,和编译时产生编译错误或 警告是能够显示行号。
2. 编译阶段:将经过预处理后的预编译文件转换成特定汇编代码,生成汇编文件

   把预编译之后生成的 xxx.i 或 xxx.ii 文件，进行一系列词法分析.语法分析.语义分析及优化 后，生成相应的汇编代码文件。

   1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字 符序列分割成一系列的记号。
   2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器 输出的语法树是一种以表达式为节点的树。
   3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有 意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运 行期才能确定的语义。
   4. 优化：源代码级别的一个优化过程。
   5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列—— 汇编语言表示。
   6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式.使 用位移来替代乘法运算.删除多余的指令等。
3. 汇编阶段:将编译阶段生成的汇编文件转化成机器码,生成可重定位目标文件

   将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更 简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对 照表一一翻译过来，汇编过程有汇编器 as 完成。经汇编之后，产生目标文件(与可执行文件格式 几乎一样)xxx.o(Windows 下)、xxx.obj(Linux 下)。
4. 链接阶段:将多个目标文件及所需要的库连接成最终的可执行目标文件

   * 静态链接：
     函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接 器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
     * 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对 同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
     * 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
     * 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何 东西，在执行的时候运行速度快。
   * 动态链接：
     动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在 一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文 件。
     * 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多 分，副本，而是这多个程序在执行时共享同一份副本；
     * 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下 一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
     * 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有 一定损失。

## include ""和<> 的区别

* 编译器预处理阶段查找头文件的路径不一样。
* ""包含的头文件 查找顺序
* 当前头文件目录
* 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径)
* 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径
* 对于使用尖括号包含的头文件
* 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径)
* 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路

## malloc 原理 brk系统调用和mmap系统调用的作用分别是什么

* Malloc 用于动态分配内存 为了减少内存碎片和系统调用的开销 malloc 使用**内存池**的方式 先申请大块内存作为**堆区** 然后将堆区分为多个内存块。一块作为内存管理的基本单位。放用户申请内存时,直接从堆分配一块合石的空闲块。Malloc 采用**隐式链表**将堆区分为连续的 大小不一的块 ,包含已分配块和未分配块 同时采用**显式链表**管理所有**空闲的块**。即使用一个双向链表将空闲块连接起来,每一个空闲块记录了一个连续的未分配的地址。
* 内存分配时 malloc 会通过隐式链表遍历所有空闲的块 选择满足需求的块进行分配
* 内存合并时 采用非边界标记算法 根据每个块的前后快是否分配来决定是否合并
* 申请内存一半会通过brk和mmap系统调用进行申请 小于128K时。会使用系统函数brk再堆区分配,大于128K 时 会使用系统函数mmap在映射区分配

## GDB

GDB 的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过 断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数 据结构是如何影响代码运行的。

### 条件断点

条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。 例如：(gdb)break 666 if testsize==100

## 段错误

* 访问非法地址内存:
* 使用野指针
* 试图修改字符串常量的内容

## new和malloc

| new                                                                                                                | malloc                                                           |
| ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------- |
| 数据类型进行分配                                                                                                   | 指定的大小分配                                                   |
| 返回的是指定对象的指针而                                                                                           | 返回的是 void*,因此 malloc 的返回值一般都需要进行类型转化。      |
| new 不仅分配一段内存,而且会调用构造函数                                                                            | 分配的内存要用 delete 销毁,delete 销毁的时候会调用对象的析构函数 |
| new 是一个操作符可以重载                                                                                           | malloc 是一个库函数。                                            |
| new 没用这样操作                                                                                                   | malloc 分配的内存不够的时候,可以用 realloc 扩容。。              |
| new 如果分配失败了会抛出 bad_malloc 的异常                                                                         | 而 malloc 失败了会返回 NULL。                                    |
| 申请数组时: new[]一次分配所有内存,多次调用构造函数,搭配使用 delete[],delete[]多次调用析构函数,销毁数组中的每个对象 | 而 malloc 则只能 sizeof(int) * n。                               |

## 内存相关API

* Linux 允许不同进程访问同一个逻辑内存,提供了一组 API,头文件在 sys/shm.h 中。
* 1)新建共享内存 shmget
  * int shmget(key_t key,size_t size,int shmflg);
  * key:共享内存键值,可以理解为共享内存的唯一性标记。
  * size:共享内存大小 shm
  * flag:创建进程和其他进程的读写权限标识。 返回值:相应的共享内存标识符,失败返回-1
* 2)连接共享内存到当前进程的地址空间 shmat
  * void *shmat(int shm_id,const void *shm_addr,int shmflg);
  * shm_id:共享内存标识符
  * shm_addr:指定共享内存连接到当前进程的地址,通常为 0,表示由系统来选择。
  * shmflg:标志位 返回值:指向共享内存第一个字节的指针,失败返回-1
  * 当前进程分离共享内存 shmdt
* int shmdt(const void *shmaddr);
  * 控制共享内存 shmctl 和信号量的 semctl 函数类似,控制共享内存
* int shmctl(int shm_id,int command,struct shmid_ds *buf);
  * shm_id:共享内存标识符
  * command: 有三个值
  * IPC_STAT:获取共享内存的状态,把共享内存的 shmid_ds 结构复制到 buf 中。
  * IPC_SET:设置共享内存的状态,把 buf 复制到共享内存的 shmid_ds 结构。
  * IPC_RMID:删除共享内存 buf:共享内存管理结构体。

## STL 内存优化

* 二级内存配置结构
  * 第一级配置器
    * 以 malloc(),free(),realloc()等 C 函数执行实际的内存配置.释放.重新配置等操作,并且能在内存需求不被满足的时候,调用一个指定的函数。
    * 一级空间配置器分配的是大于 128 字节的空间
    * 如果分配不成功,调用句柄释放一部分内存
    * 如果还不能分配成功,抛出异常
  * 第二级配置器
    * 在 STL 的第二级配置器中多了一些机制,避免太多小区块造成的内存碎片,小额区块带来的不仅是内存碎片,配置时还有额外的负担。区块越小,额外负担所占比例就越大
* 分配原则
  * 如果要分配的区块大于 128bytes,则移交给第一级配置器处理。
  * 如果要分配的区块小于 128bytes,则以内存池管理(memory pool),又称之次层配置(sub-allocation):每次配置一大块内存,并维护对应的 16 个空闲链表(free-list)。下次若有相同大小的内存需求,则直接从 free-list 中取。如果有小额区块被释放,则由配置器回收到 free-list 中。
  * 当用户申请的空间小于 128 字节时,将字节数扩展到 8 的倍数,然后在自由链表中查找对应大小的子链表
    * 如果在自由链表查找不到或者块数不够,则向内存池进行申请,一般一次申请 20 块
    * 如果内存池空间足够,则取出内存
    * 如果不够分配 20 块,则分配最多的块数给自由链表,并且更新每次申请的块数
      如果一块都无法提供,则把剩余的内存挂到自由链表,然后向系统 heap 申请空间,如果申请失败,则看看自由链表还有没有可用的块,如果也没有,则最后调用一级空间配置器
  * 二级内存池
    二级内存池采用了16个空闲链表,这里的16个空闲链表分别管理大小为8.16.24......120.128 的数据块。这里空闲链表节点的设计十分巧妙,这里用了一个联合体既可以表示下一个空闲数据块(存在于空闲链表中)的地址,也可以表示已经被用户使用的数据块(不存在空闲链表中)的地址。
    * ![image-20200706134604300](E:/Notes/MarkDown/计算机课程学习/imgs/C++面试_5_3.jpg)
    * 空间配置函数 allocate
      首先先要检查申请空间的大小,如果大于 128 字节就调用第一级配置器,小于 128 字节就检查对应的空闲链表,如果该空闲链表中有可用数据块,则直接拿来用(拿取空闲链表中的第一个可用数据块,然后把该空闲链表的地址设置为该数据块指向的下一个地址),如果没有可用数据块,则调用 refill 重新填充空间。
    * 空间释放函数 deallocate首先先要检查释放数据块的大小,如果大于 128 字节就调用第一级配置器,小于 128 字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。
    * 重新填充空闲链表 refill 在用 allocate 配置空间时,如果空闲链表中没有可用数据块,就会调用 refill 来重新填充空间,新的空间取自内存池。缺省取 20 个数据块,如果内存池空间不足,那么能取多少个节 点就取多少个。
      从内存池取空间给空闲链表用是 chunk_alloc 的工作,首先根据 end_free-start_free 来判断内存池中的剩余空间是否足以调出 nobjs 个大小为 size 的数据块出去,如果内存连一个数 据块的空间都无法供应,需要用 malloc 取堆中申请内存。假如山穷水尽,整个系统的堆空间都不够用了,malloc 失败,那么 chunk_alloc 会从空闲链表中找是否有大的数据块,然后将该数据块的空间分给内存池(这个数据块会从链表中去除)。
  * 总结:
    * 使用 allocate 向内存池请求 size 大小的内存空间,
      * 如果需要请求的内存大小大于128bytes,直接使用 malloc。
      * 如果需要的内存大小小于 128bytes,allocate 根据 size 找到最适合的自由链表。
        * 如果链表不为空,返回第一个 node,链表头改为第二个 node。
        * 如果链表为空,使用 blockAlloc 请求分配 node。
          * 如果内存池中有大于一个node的空间,分配竟可能多的node(但是最多20个),将一个 node 返回,其他的 node 添加到链表中。
          * 如果内存池只有一个 node 的空间,直接返回给用户。
          * 若果如果连一个 node 都没有,再次向操作系统请求分配内存。
            * 分配成功,再次进行 b 过程。
            * 分配失败,循环各个自由链表,寻找空间。
              * 找到空间,再次进行过程 b
              * 找不到空间,抛出异常。
    * 用户调用 deallocate 释放内存空间,如果要求释放的内存空间大于 128bytes,直接调用 free。
    * 否则按照其大小找到合适的自由链表,并将其插入。

```FLOW
        st=>start: 开始框
        128byte=>condition: 内存大于128bytes
        malloc=>operation: 调用malloc
        fl=>operation: 寻找最合适的list
        isempty=>condition: 链表是否为空
        rn=>operation: 返回第一个node链表头 改为第二个node
        ms=>operation: 使用blockAlloc请求分配node
        isnempty=>condition: 是否有大于等于1node的空间
        iseempty=>condition: 是否有等于1node的空间
        ismore1=>condition: 是否有node的空间
        more1=>operation: 分配尽可能多的node[不超过20] 将一个node返回 其他node 添加到链表中
        equal1=>operation: 直接返回node
        less1=>condition: 一个node都没有 再次向系统申请内存分配
        mallocs=>operation: 分配成功 执行b过程
        mallocf=>condition: 分配失败 循环各个自由链表 寻找空间
        fss=>operation: 找到空间再次分配
        fsf=>operation: 找不到空间抛出异常
        e=>end: 结束框
        st()->128byte
        128byte(yes)->malloc->e
        128byte(no)->fl->isempty
        isempty(yes)->ms->isnempty
        isempty(no)->rn->e
        isnempty(yes)->iseempty
        iseempty(yes)->more1
        iseempty(no)->equal1
        isnempty(no)->less1
        less1(yes)->mallocs
        less1(no)->mallocf
        mallocf(yes)->fss
        mallocf(no)->fsf
```

## IO 模型

* 阻塞 IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函 数有没有返回，必须等这个函数返回才能进行下一步动作
* 非阻塞 IO:非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。没有就绪就可以做其他事。
* 信号驱动 IO:信号驱动 IO:linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继 续运行并不阻塞，当 IO 时间就绪，进程收到 SIGIO 信号。然后处理 IO 事件。
* IO 复用/多路转接 IO:linux 用 select/poll 函数实现 IO 复用模型，这两个函数也会使进程阻 塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操 作、写操作的 IO 函数进行检测。知道有数据可读或可写时，才真正调用 IO 操作函数
* 异步 IO:linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件 偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

## page cache

加快文件读取速率

page cache 中由一部分磁盘文件的缓存。

读取文件先去page cache 中查找 如果命中就不用去磁盘中读取。提高读取速度。

在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过 两个数据结构来管理这些 Cache 项，一个是 radix tree，另一个是双向链表。

Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位 Cache 项

## Linux 怎么获得文件的100-200行

```shell
sed -n '100,200p' inputfile 
awk 'NR>=100&&NR<=200{print}' inputfile 
head -200 inputfile|tail -100
```

## awk

* 作用

  样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、 对输入执行计算以及生成报表，还有无数其他的功能。
* 用法

```shell
awk [-F field-separator] 'commands' input-file(s)
```

* 内置变量

| 命令     | 介绍                                   |
| -------- | -------------------------------------- |
| ARGC     | 命令行参数个数                         |
| ARGV     | 命令行参数排列                         |
| ENVIRON  | 支持队列中系统环境变量的使用           |
| FILENAME | awk 浏览的文件名                       |
| FNR      | 浏览文件的记录数                       |
| FS       | 设置输入域分隔符，等价于命令行 -F 选项 |
| NF       | 浏览记录的域的个数                     |
| NR       | 已读的记录数                           |
| OFS      | 输出域分隔符                           |
| ORS      | 输出记录分隔符                         |
| RS       | 控制记录分隔符                         |

例子

1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小

```shell
> ls -l | awk '{print $5 "\t" $9}'
```

读入有'\n'换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0 则表示 所有域,$1 表示第一个域,$n 表示第 n 个域。默认域分隔符是"空白键" 或 "[tab]键"。

2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序

```shell
> ls -l | awk 'BEGIN {COUNT = -1; print "BEGIN COUNT"} {COUNT = COUNT + 1; print COUNT"\t"$5"\t"$9}END {print "END, COUNT = "COUNT}' 
```

先处理 BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行 END 操作。 3、找到当前文件夹下所有的子文件夹,并显示排序
ls -l | awk 'BEGIN {print "BEGIN COUNT"} /4096/{print NR"\t"$5"\t"$9} END {print "END"}' * /4096/ 正则匹配式子

* 使用 print $NF 可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段， 其他以此类推

## Linux内核中Timer定时器机制

### 低精度时钟

Linux 2.6.16 之前，内核只支持低精度时钟，内核定时器的工作方式：

* 系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。
* 内核会根据 HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动 tick(节拍)
  中断。HZ 表示 1 秒种产生多少个时钟硬件中断，tick 就表示连续两个中断的间隔时间。
* 设置时钟事件设备后，时钟事件设备会定时产生一个 tick 中断，触发时钟中断处理函数，更新系统时钟,并检测 timer wheel，进行超时事件的处理。

在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用 timer wheel 多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel 的触发是基于系统 tick 周期性中断。
所以说这之前，linux 只能支持 ms 级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。

### 高精度时钟

Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器 hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：
hrtimer 采用红黑树进行高精度定时器的管理，而不是时间轮；
高精度时钟定时器不在依赖系统的 tick 中断，而是基于事件触发。
旧内核的定时器实现依赖于系统定时器硬件定期的 tick，基于该 tick，内核会扫描 timer wheel 处理超时事件，会更新 jiffies，wall time(墙上时间，现实时间)，process 的使用时间
等等工作。
新的内核不再会直接支持周期性的 tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了 hrtimer(high resolution timer)：于事件触发。
hrtimer 的工作原理：
通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的 Timer 的时间，时
钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。
在高精度时钟模式下，操作系统内核仍然需要周期性的 tick 中断，以便刷新内核的一些任
务。hrtimer 是基于事件的，不会周期性出发 tick 中断，所以为了实现周期性的 tick 中断
(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个
tick 时长，在超时回来后，完成对应的工作，然后再次设置下一个 tick 的超时时间，以此达到
周期性 tick 中断的需求。
引入了 dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生 tickless
情况下，会跳过一些 tick。
新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：
时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如
=======

---

title: test
tag: [计算机课程学习,Test,]
---------------------------

* * ## 硬链接和软链接


    * 好处:隐藏文件路径.增加权限安全及节省存储等好处
    * 硬链接:同一个问价使用了不同的别名 使用ln创建
    * 文件用户数据块中存放的内容是另一个文件的路径名指向 则该文件为软连接。软链接是个普通文件 有自己独立inode 文件内容比较特殊

    ## 大端 小端

    [大端 小端](https://blog.csdn.net/qqliyunpeng/article/details/68484497) [联合体union 一个union代表多个类型 共享内存0](https://blog.csdn.net/u013066730/article/details/84638489)

    * 大端是指低字节存储在高地址
    * 小端存储是指低字节存储在低地址。
    * 我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。

    ```C++
    int fun()
    {
        union test{int i;char c;}
        test t;t.i = 1;
        //如果是大端t.c 为0x00 t.c!=1 返回0
        //	  是小端他t.c的值为1 返回1
        return t.c==1;
    }
    ```

    ## 静态变量 初始化

    静态变量 储存在虚拟地址空间的数据段和BSS段

    * C语言在代码执行前初始化 属于编译器初始化
    * C++中由于引入对象,对象生成必须调用构造函数,因此 C++规定全局或局部 静态对象当且仅当对象首次用到时进行构造

    ## 用户态和内核态

    操作系统的两种运行级别。

    用户态拥有最低的特权级。运行在用户态的程序不能直接访问操作系统内核数据 结构和程序。

    内核态拥有最高的特权级。

    内核态和用户态之间的转换方式主要包括:系统调用,异常和中断。

    ## 内存溢出和内存泄漏

    ### 内存溢出

    程序申请内存的时候 没有足够的内存供申请者使用。

    内存溢出就是你要的内存空间超过了系统实 际分配给你的空间,此时系统相当于没法满足你的需求,就会报内存溢出的错误

    产生的原因:

    * 内存中加载的数据量过于庞大,如一次从数据库取出过多数据
    * 集合类中有对对象的引用,使用完后未清空,使得不能回收
    * 代码中存在死循环或循环产生过多重复的对象实体
    * 使用的第三方软件中的 BUG
    * 启动参数内存值设定的过小

    ### 内存泄漏

    * 内存泄漏通常是由于调用了malloc/new等内存申请的操作,但是缺少了对应free/delete。为了**判断**内存是否泄露。
    * 使用 linux 环境下的内存泄漏检查工具 Valgrind
    * 我们在写代码时可以添加内存申请和释放的统计功能,统计当前申请和释放的内存是否一致, 以此来判断内存是否泄露。
    * 分类
      * 堆内存泄漏:对内存指的是程序运行中根据需要分配通过 malloc,realloc,new 等从堆中分配的一块内存,再是完成后必须通过调用对应的 free 或者 delete 删掉。如果 程序的设计的错误导致这部分内存没有被释放,那么此后这块内存将不会被使用,就会产生 Heap Leak.
      * 系统资源泄漏:要指程序使用系统分配的资源比如Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉,导致系统资源的浪费,严重可导致系统 效能降低,系统运行不稳定。
      * 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时,如果基类的析构函
        数不是 virtual,那么子类的析构函数将不会被调用,子类的资源没有正确是释放,因此造成内 存泄露。

    ## 对于 C++源文件,从文本到可执行文件一般需要四个过程:

    1. 预处理阶段:对源代码文件中文件包含关系(头文件).预编译语句(宏定义)进行分析和替换,生成预编译文件。

       主要处理源代码文件中的以"#"开头的预编译指令。处理规则见下

       1. 删除所有的#define,展开所有的宏定义
       2. 处理所有的条件预编译指令,如"#if"."#endif"."#ifdef"."#elif"和"#else"。
       3. 处理"#include"预编译指令,将文件内容替换到它的位置,这个过程是递归进行的,文件 中包含其他文件。
       4. 删除所有的注释,"//"和"/**/"。
       5. 保留所有的#pragma 编译器指令,编译器需要用到他们,如:#pragma once 是为了防止有文 件被重复引用。
       6. 添加行号和文件标识,便于编译时编译器产生调试用的行号信息,和编译时产生编译错误或 警告是能够显示行号。
    2. 编译阶段:将经过预处理后的预编译文件转换成特定汇编代码,生成汇编文件

       把预编译之后生成的 xxx.i 或 xxx.ii 文件，进行一系列词法分析.语法分析.语义分析及优化 后，生成相应的汇编代码文件。

       1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字 符序列分割成一系列的记号。
       2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器 输出的语法树是一种以表达式为节点的树。
       3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有 意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运 行期才能确定的语义。
       4. 优化：源代码级别的一个优化过程。
       5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列—— 汇编语言表示。
       6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式.使 用位移来替代乘法运算.删除多余的指令等。
    3. 汇编阶段:将编译阶段生成的汇编文件转化成机器码,生成可重定位目标文件

       将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更 简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对 照表一一翻译过来，汇编过程有汇编器 as 完成。经汇编之后，产生目标文件(与可执行文件格式 几乎一样)xxx.o(Windows 下)、xxx.obj(Linux 下)。
    4. 链接阶段:将多个目标文件及所需要的库连接成最终的可执行目标文件

       * 静态链接：
         函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接 器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
         * 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对 同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
         * 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
         * 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何 东西，在执行的时候运行速度快。
       * 动态链接：
         动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在 一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文 件。
         * 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多 分，副本，而是这多个程序在执行时共享同一份副本；
         * 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下 一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
         * 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有 一定损失。

    ## include ""和<> 的区别

    * 编译器预处理阶段查找头文件的路径不一样。
    * ""包含的头文件 查找顺序
    * 当前头文件目录
    * 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径)
    * 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径
    * 对于使用尖括号包含的头文件
    * 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径)
    * 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路

    ## malloc 原理 brk系统调用和mmap系统调用的作用分别是什么

    * Malloc 用于动态分配内存 为了减少内存碎片和系统调用的开销 malloc 使用**内存池**的方式 先申请大块内存作为**堆区** 然后将堆区分为多个内存块。一块作为内存管理的基本单位。放用户申请内存时,直接从堆分配一块合石的空闲块。Malloc 采用**隐式链表**将堆区分为连续的 大小不一的块 ,包含已分配块和未分配块 同时采用**显式链表**管理所有**空闲的块**。即使用一个双向链表将空闲块连接起来,每一个空闲块记录了一个连续的未分配的地址。
    * 内存分配时 malloc 会通过隐式链表遍历所有空闲的块 选择满足需求的块进行分配
    * 内存合并时 采用非边界标记算法 根据每个块的前后快是否分配来决定是否合并
    * 申请内存一半会通过brk和mmap系统调用进行申请 小于128K时。会使用系统函数brk再堆区分配,大于128K 时 会使用系统函数mmap在映射区分配

    ## GDB

    GDB 的出现减轻了开发人员的负担，他们可以在程序运行的时候单步跟踪自己的代码，或者通过 断点暂时中止程序的执行。此外，他们还能够随时察看变量和内存的当前状态，并监视关键的数 据结构是如何影响代码运行的。

    ### 条件断点

    条件断点是当满足条件就中断程序运行，命令：break line-or-function if expr。 例如：(gdb)break 666 if testsize==100

    ## 段错误

    * 访问非法地址内存:
    * 使用野指针
    * 试图修改字符串常量的内容

    ## new和malloc

    | new                                                                                                                | malloc                                                           |
    | ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------- |
    | 数据类型进行分配                                                                                                   | 指定的大小分配                                                   |
    | 返回的是指定对象的指针而                                                                                           | 返回的是 void*,因此 malloc 的返回值一般都需要进行类型转化。      |
    | new 不仅分配一段内存,而且会调用构造函数                                                                            | 分配的内存要用 delete 销毁,delete 销毁的时候会调用对象的析构函数 |
    | new 是一个操作符可以重载                                                                                           | malloc 是一个库函数。                                            |
    | new 没用这样操作                                                                                                   | malloc 分配的内存不够的时候,可以用 realloc 扩容。。              |
    | new 如果分配失败了会抛出 bad_malloc 的异常                                                                         | 而 malloc 失败了会返回 NULL。                                    |
    | 申请数组时: new[]一次分配所有内存,多次调用构造函数,搭配使用 delete[],delete[]多次调用析构函数,销毁数组中的每个对象 | 而 malloc 则只能 sizeof(int) * n。                               |

    ## 内存相关API

    * Linux 允许不同进程访问同一个逻辑内存,提供了一组 API,头文件在 sys/shm.h 中。
    * 1)新建共享内存 shmget
      * int shmget(key_t key,size_t size,int shmflg);
      * key:共享内存键值,可以理解为共享内存的唯一性标记。
      * size:共享内存大小 shm
      * flag:创建进程和其他进程的读写权限标识。 返回值:相应的共享内存标识符,失败返回-1
    * 2)连接共享内存到当前进程的地址空间 shmat
      * void *shmat(int shm_id,const void *shm_addr,int shmflg);
      * shm_id:共享内存标识符
      * shm_addr:指定共享内存连接到当前进程的地址,通常为 0,表示由系统来选择。
      * shmflg:标志位 返回值:指向共享内存第一个字节的指针,失败返回-1
      * 当前进程分离共享内存 shmdt
    * int shmdt(const void *shmaddr);
      * 控制共享内存 shmctl 和信号量的 semctl 函数类似,控制共享内存
    * int shmctl(int shm_id,int command,struct shmid_ds *buf);
      * shm_id:共享内存标识符
      * command: 有三个值
      * IPC_STAT:获取共享内存的状态,把共享内存的 shmid_ds 结构复制到 buf 中。
      * IPC_SET:设置共享内存的状态,把 buf 复制到共享内存的 shmid_ds 结构。
      * IPC_RMID:删除共享内存 buf:共享内存管理结构体。

    ## STL 内存优化

    * 二级内存配置结构
      * 第一级配置器
        * 以 malloc(),free(),realloc()等 C 函数执行实际的内存配置.释放.重新配置等操作,并且能在内存需求不被满足的时候,调用一个指定的函数。
        * 一级空间配置器分配的是大于 128 字节的空间
        * 如果分配不成功,调用句柄释放一部分内存
        * 如果还不能分配成功,抛出异常
      * 第二级配置器
        * 在 STL 的第二级配置器中多了一些机制,避免太多小区块造成的内存碎片,小额区块带来的不仅是内存碎片,配置时还有额外的负担。区块越小,额外负担所占比例就越大
    * 分配原则
      * 如果要分配的区块大于 128bytes,则移交给第一级配置器处理。
      * 如果要分配的区块小于 128bytes,则以内存池管理(memory pool),又称之次层配置(sub-allocation):每次配置一大块内存,并维护对应的 16 个空闲链表(free-list)。下次若有相同大小的内存需求,则直接从 free-list 中取。如果有小额区块被释放,则由配置器回收到 free-list 中。
      * 当用户申请的空间小于 128 字节时,将字节数扩展到 8 的倍数,然后在自由链表中查找对应大小的子链表
        * 如果在自由链表查找不到或者块数不够,则向内存池进行申请,一般一次申请 20 块
        * 如果内存池空间足够,则取出内存
        * 如果不够分配 20 块,则分配最多的块数给自由链表,并且更新每次申请的块数
          如果一块都无法提供,则把剩余的内存挂到自由链表,然后向系统 heap 申请空间,如果申请失败,则看看自由链表还有没有可用的块,如果也没有,则最后调用一级空间配置器
      * 二级内存池
        二级内存池采用了16个空闲链表,这里的16个空闲链表分别管理大小为8.16.24......120.128 的数据块。这里空闲链表节点的设计十分巧妙,这里用了一个联合体既可以表示下一个空闲数据块(存在于空闲链表中)的地址,也可以表示已经被用户使用的数据块(不存在空闲链表中)的地址。
        * ![image-20200706134604300](E:/Notes/MarkDown/计算机课程学习/imgs/C++面试_5_3.jpg)
        * 空间配置函数 allocate
          首先先要检查申请空间的大小,如果大于 128 字节就调用第一级配置器,小于 128 字节就检查对应的空闲链表,如果该空闲链表中有可用数据块,则直接拿来用(拿取空闲链表中的第一个可用数据块,然后把该空闲链表的地址设置为该数据块指向的下一个地址),如果没有可用数据块,则调用 refill 重新填充空间。
        * 空间释放函数 deallocate首先先要检查释放数据块的大小,如果大于 128 字节就调用第一级配置器,小于 128 字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。
        * 重新填充空闲链表 refill 在用 allocate 配置空间时,如果空闲链表中没有可用数据块,就会调用 refill 来重新填充空间,新的空间取自内存池。缺省取 20 个数据块,如果内存池空间不足,那么能取多少个节 点就取多少个。
          从内存池取空间给空闲链表用是 chunk_alloc 的工作,首先根据 end_free-start_free 来判断内存池中的剩余空间是否足以调出 nobjs 个大小为 size 的数据块出去,如果内存连一个数 据块的空间都无法供应,需要用 malloc 取堆中申请内存。假如山穷水尽,整个系统的堆空间都不够用了,malloc 失败,那么 chunk_alloc 会从空闲链表中找是否有大的数据块,然后将该数据块的空间分给内存池(这个数据块会从链表中去除)。
      * 总结:
        * 使用 allocate 向内存池请求 size 大小的内存空间,
          * 如果需要请求的内存大小大于128bytes,直接使用 malloc。
          * 如果需要的内存大小小于 128bytes,allocate 根据 size 找到最适合的自由链表。
            * 如果链表不为空,返回第一个 node,链表头改为第二个 node。
            * 如果链表为空,使用 blockAlloc 请求分配 node。
              * 如果内存池中有大于一个node的空间,分配竟可能多的node(但是最多20个),将一个 node 返回,其他的 node 添加到链表中。
              * 如果内存池只有一个 node 的空间,直接返回给用户。
              * 若果如果连一个 node 都没有,再次向操作系统请求分配内存。
                * 分配成功,再次进行 b 过程。
                * 分配失败,循环各个自由链表,寻找空间。
                  * 找到空间,再次进行过程 b
                  * 找不到空间,抛出异常。
        * 用户调用 deallocate 释放内存空间,如果要求释放的内存空间大于 128bytes,直接调用 free。
        * 否则按照其大小找到合适的自由链表,并将其插入。

    ```FLOW
            st=>start: 开始框
            128byte=>condition: 内存大于128bytes
            malloc=>operation: 调用malloc
            fl=>operation: 寻找最合适的list
            isempty=>condition: 链表是否为空
            rn=>operation: 返回第一个node链表头 改为第二个node
            ms=>operation: 使用blockAlloc请求分配node
            isnempty=>condition: 是否有大于等于1node的空间
            iseempty=>condition: 是否有等于1node的空间
            ismore1=>condition: 是否有node的空间
            more1=>operation: 分配尽可能多的node[不超过20] 将一个node返回 其他node 添加到链表中
            equal1=>operation: 直接返回node
            less1=>condition: 一个node都没有 再次向系统申请内存分配
            mallocs=>operation: 分配成功 执行b过程
            mallocf=>condition: 分配失败 循环各个自由链表 寻找空间
            fss=>operation: 找到空间再次分配
            fsf=>operation: 找不到空间抛出异常
            e=>end: 结束框
            st()->128byte
            128byte(yes)->malloc->e
            128byte(no)->fl->isempty
            isempty(yes)->ms->isnempty
            isempty(no)->rn->e
            isnempty(yes)->iseempty
            iseempty(yes)->more1
            iseempty(no)->equal1
            isnempty(no)->less1
            less1(yes)->mallocs
            less1(no)->mallocf
            mallocf(yes)->fss
            mallocf(no)->fsf
    ```

    ## IO 模型

    * 阻塞 IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函 数有没有返回，必须等这个函数返回才能进行下一步动作
    * 非阻塞 IO:非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。没有就绪就可以做其他事。
    * 信号驱动 IO:信号驱动 IO:linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继 续运行并不阻塞，当 IO 时间就绪，进程收到 SIGIO 信号。然后处理 IO 事件。
    * IO 复用/多路转接 IO:linux 用 select/poll 函数实现 IO 复用模型，这两个函数也会使进程阻 塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操 作、写操作的 IO 函数进行检测。知道有数据可读或可写时，才真正调用 IO 操作函数
    * 异步 IO:linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件 偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

    ## page cache

    加快文件读取速率

    page cache 中由一部分磁盘文件的缓存。

    读取文件先去page cache 中查找 如果命中就不用去磁盘中读取。提高读取速度。

    在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过 两个数据结构来管理这些 Cache 项，一个是 radix tree，另一个是双向链表。

    Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位 Cache 项

    ## Linux 怎么获得文件的100-200行

    ```shell
    sed -n '100,200p' inputfile 
    awk 'NR>=100&&NR<=200{print}' inputfile 
    head -200 inputfile|tail -100
    ```

    ## awk

    * 作用

      样式扫描和处理语言。它允许创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、 对输入执行计算以及生成报表，还有无数其他的功能。
    * 用法

    ```shell
    awk [-F field-separator] 'commands' input-file(s)
    ```

    * 内置变量

    | 命令     | 介绍                                   |
    | -------- | -------------------------------------- |
    | ARGC     | 命令行参数个数                         |
    | ARGV     | 命令行参数排列                         |
    | ENVIRON  | 支持队列中系统环境变量的使用           |
    | FILENAME | awk 浏览的文件名                       |
    | FNR      | 浏览文件的记录数                       |
    | FS       | 设置输入域分隔符，等价于命令行 -F 选项 |
    | NF       | 浏览记录的域的个数                     |
    | NR       | 已读的记录数                           |
    | OFS      | 输出域分隔符                           |
    | ORS      | 输出记录分隔符                         |
    | RS       | 控制记录分隔符                         |

    例子

    1、找到当前文件夹下所有的文件和子文件夹,并显示文件大小

    ```shell
    > ls -l | awk '{print $5 "\t" $9}'
    ```

    读入有'\n'换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域。$0 则表示 所有域,$1 表示第一个域,$n 表示第 n 个域。默认域分隔符是"空白键" 或 "[tab]键"。

    2、找到当前文件夹下所有的文件和子文件夹，并显示文件大小，并显示排序

    ```shell
    > ls -l | awk 'BEGIN {COUNT = -1; print "BEGIN COUNT"} {COUNT = COUNT + 1; print COUNT"\t"$5"\t"$9}END {print "END, COUNT = "COUNT}' 
    ```

    先处理 BEGIN， 然后进行文本分析，进行第二个{}的操作，分析完进行 END 操作。 3、找到当前文件夹下所有的子文件夹,并显示排序
    ls -l | awk 'BEGIN {print "BEGIN COUNT"} /4096/{print NR"\t"$5"\t"$9} END {print "END"}' * /4096/ 正则匹配式子

    * 使用 print $NF 可以打印出一行中的最后一个字段，使用$(NF-1)则是打印倒数第二个字段， 其他以此类推

    ## Linux内核中Timer定时器机制

    ### 低精度时钟

    Linux 2.6.16 之前，内核只支持低精度时钟，内核定时器的工作方式：

    * 系统启动后，会读取时钟源设备(RTC, HPET，PIT…)，初始化当前系统时间。
    * 内核会根据 HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动 tick(节拍)
      中断。HZ 表示 1 秒种产生多少个时钟硬件中断，tick 就表示连续两个中断的间隔时间。
    * 设置时钟事件设备后，时钟事件设备会定时产生一个 tick 中断，触发时钟中断处理函数，更新系统时钟,并检测 timer wheel，进行超时事件的处理。

    在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用 timer wheel 多级时间轮的实现机制，维护操作系统的所有定时事件。timer wheel 的触发是基于系统 tick 周期性中断。
    所以说这之前，linux 只能支持 ms 级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟的内核设计。

    ### 高精度时钟

    Linux 2.6.16 ，内核支持了高精度的时钟，内核采用新的定时器 hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别：
    hrtimer 采用红黑树进行高精度定时器的管理，而不是时间轮；
    高精度时钟定时器不在依赖系统的 tick 中断，而是基于事件触发。
    旧内核的定时器实现依赖于系统定时器硬件定期的 tick，基于该 tick，内核会扫描 timer wheel 处理超时事件，会更新 jiffies，wall time(墙上时间，现实时间)，process 的使用时间
    等等工作。
    新的内核不再会直接支持周期性的 tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了 hrtimer(high resolution timer)：于事件触发。
    hrtimer 的工作原理：
    通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的 Timer 的时间，时
    钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。
    在高精度时钟模式下，操作系统内核仍然需要周期性的 tick 中断，以便刷新内核的一些任
    务。hrtimer 是基于事件的，不会周期性出发 tick 中断，所以为了实现周期性的 tick 中断
    (dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个
    tick 时长，在超时回来后，完成对应的工作，然后再次设置下一个 tick 的超时时间，以此达到
    周期性 tick 中断的需求。
    引入了 dynamic tick，是为了能够在使用高精度时钟的同时节约能源，这样会产生 tickless
    情况下，会跳过一些 tick。
    新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：
    时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如

>>>>>>> 0f26ed6 (add new notes)
>>>>>>> RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT 等
>>>>>>>
>>>>>>
>>>>>
>>>>
>>>
>>
